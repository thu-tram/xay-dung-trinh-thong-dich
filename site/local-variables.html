<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Local Variables &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#biểu-diễn-biến-local"><small>22.1</small> Biểu diễn biến Local</a></li>
    <li><a href="#câu-lệnh-block"><small>22.2</small> Câu lệnh Block</a></li>
    <li><a href="#khai-báo-biến-local"><small>22.3</small> Khai báo biến Local</a></li>
    <li><a href="#sử-dụng-biến-local"><small>22.4</small> Sử dụng biến Local</a></li>
    <li><a href="#thử-thách"><small>22.5</small> Thử thách</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="global-variables.html" title="Global Variables" class="prev">←</a>
<a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Local Variables<small>22</small></a></h3>

<ul>
    <li><a href="#biểu-diễn-biến-local"><small>22.1</small> Biểu diễn biến Local</a></li>
    <li><a href="#câu-lệnh-block"><small>22.2</small> Câu lệnh Block</a></li>
    <li><a href="#khai-báo-biến-local"><small>22.3</small> Khai báo biến Local</a></li>
    <li><a href="#sử-dụng-biến-local"><small>22.4</small> Sử dụng biến Local</a></li>
    <li><a href="#thử-thách"><small>22.5</small> Thử thách</a></li>
</ul>


<div class="prev-next">
    <a href="global-variables.html" title="Global Variables" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="jumping-back-and-forth.html" title="Jumping Back and Forth" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">22</div>
  <h1>Local Variables</h1>

<blockquote>
<p>Và khi trí tưởng tượng hiện hình<br />
Những hình thái của điều chưa biết, ngòi bút thi nhân<br />
Biến chúng thành hình dạng và trao cho hư vô<br />
Một chốn trú ngụ và một cái tên.</p>
<p><cite>William Shakespeare, <em>Giấc mộng đêm hè</em></cite></p>
</blockquote>
<p><a href="global-variables.html">Chương trước</a> đã giới thiệu biến trong clox, nhưng mới chỉ ở dạng <span name="global">global</span>. Trong chương này, ta sẽ mở rộng để hỗ trợ block, block scope và biến local. Trong jlox, ta gói gọn cả phần này và biến global trong một chương. Với clox, đây sẽ là khối lượng công việc của hai chương, một phần vì, thật lòng mà nói, mọi thứ trong C đều tốn nhiều công sức hơn.</p>
<aside name="global">
<p>Chắc hẳn ở đây có thể chêm một câu đùa kiểu “nghĩ toàn cầu, hành động địa phương”, nhưng tôi vẫn chưa nghĩ ra được.</p>
</aside>
<p>Nhưng lý do quan trọng hơn là cách tiếp cận với biến local của ta sẽ khác hẳn so với khi hiện thực biến global. Trong Lox, biến global được <strong>late bound</strong>. “Late” ở đây nghĩa là “được resolve sau khi compile xong”. Điều này tốt cho việc giữ compiler đơn giản, nhưng không tốt cho hiệu năng. Biến local là một trong những <span name="params">thành phần</span> được dùng nhiều nhất trong một ngôn ngữ. Nếu biến local chậm, <em>mọi thứ</em> sẽ chậm. Vậy nên ta muốn một chiến lược cho biến local hiệu quả nhất có thể.</p>
<aside name="params">
<p>Tham số hàm cũng được dùng rất nhiều. Chúng hoạt động giống biến local, nên ta sẽ dùng cùng kỹ thuật hiện thực cho chúng.</p>
</aside>
<p>May mắn thay, <strong>lexical scoping</strong> sẽ giúp ta. Như tên gọi, lexical scope nghĩa là ta có thể resolve một biến local chỉ bằng cách nhìn vào văn bản chương trình — biến local <em>không</em> phải late bound. Bất kỳ xử lý nào ta làm ở compiler là công việc ta <em>không</em> phải làm ở runtime, nên việc hiện thực biến local sẽ tận dụng tối đa compiler.</p>
<h2><a href="#biểu-diễn-biến-local" id="biểu-diễn-biến-local"><small>22&#8202;.&#8202;1</small>Biểu diễn biến Local</a></h2>
<p>Điều tuyệt vời khi “mổ xẻ” một ngôn ngữ lập trình thời nay là ta có cả một lịch sử dài các ngôn ngữ khác để học hỏi. Vậy C và Java quản lý biến local thế nào? Tất nhiên là trên stack! Chúng thường dùng cơ chế stack gốc do chip và hệ điều hành hỗ trợ. Điều đó hơi quá thấp tầng với ta, nhưng trong thế giới ảo của clox, ta có stack riêng để dùng.</p>
<p>Hiện tại, ta mới chỉ dùng nó để giữ <strong>temporaries</strong> — những dữ liệu sống ngắn mà ta cần nhớ trong khi tính toán một biểu thức. Miễn là không cản trở chúng, ta có thể “nhét” biến local vào stack luôn. Điều này rất tốt cho hiệu năng. Cấp phát chỗ cho một biến local mới chỉ cần tăng con trỏ <code>stackTop</code>, và giải phóng cũng chỉ cần giảm nó. Truy cập một biến ở vị trí stack đã biết chỉ là một phép truy cập mảng theo chỉ số.</p>
<p>Tuy nhiên, ta cần cẩn thận. VM kỳ vọng stack hoạt động đúng nghĩa “stack”. Ta chỉ được phép cấp phát biến local mới ở đỉnh stack, và chỉ được bỏ một biến local khi không còn gì nằm trên nó. Ngoài ra, cần đảm bảo temporaries không gây cản trở.</p>
<p>May mắn là thiết kế của Lox rất <span name="harmony">ăn khớp</span> với các ràng buộc này. Biến local mới luôn được tạo bởi câu lệnh khai báo. Câu lệnh không lồng bên trong biểu thức, nên sẽ không bao giờ có temporary trên stack khi một câu lệnh bắt đầu execute. Các block được lồng chặt chẽ. Khi một block kết thúc, nó luôn “mang theo” các biến local được khai báo gần nhất, bên trong nhất. Vì đó cũng là những biến vào scope sau cùng, chúng sẽ nằm trên đỉnh stack — đúng vị trí ta cần.</p>
<aside name="harmony">
<p>Sự ăn khớp này rõ ràng không phải ngẫu nhiên. Tôi thiết kế Lox để phù hợp với việc compile một pass sang bytecode dựa trên stack. Nhưng tôi cũng không phải chỉnh sửa ngôn ngữ quá nhiều để đáp ứng các ràng buộc đó. Phần lớn thiết kế của nó sẽ mang lại cảm giác tự nhiên.</p>
<p>Điều này phần lớn là vì lịch sử ngôn ngữ gắn chặt với compile một pass và — ở mức độ thấp hơn — kiến trúc dựa trên stack. Block scope của Lox theo truyền thống kéo dài từ thời BCPL. Là lập trình viên, trực giác của chúng ta về cái gì là “bình thường” trong một ngôn ngữ vẫn bị ảnh hưởng bởi giới hạn phần cứng của những năm xưa.</p>
</aside>
<p>Hãy bước qua ví dụ chương trình này và quan sát cách các biến local xuất hiện và biến mất khỏi scope:</p><img src="image/local-variables/scopes.png" alt="Một loạt biến local xuất hiện và biến mất khỏi scope theo kiểu stack." />
<p>Thấy chúng khớp với mô hình stack hoàn hảo chứ? Có vẻ stack sẽ hoạt động tốt để lưu biến local ở runtime. Nhưng ta còn có thể tiến xa hơn. Không chỉ biết <em>rằng</em> chúng sẽ nằm trên stack, ta còn có thể xác định chính xác <em>vị trí</em> của chúng trên stack. Vì compiler biết chính xác biến local nào đang trong scope tại mọi thời điểm, nó có thể mô phỏng stack trong quá trình compile và ghi chú <span name="fn">vị trí</span> của từng biến trong stack.</p>
<p>Ta sẽ tận dụng điều này bằng cách dùng các stack offset này làm toán hạng cho bytecode instruction đọc và ghi biến local. Điều này khiến việc làm việc với biến local nhanh đến “ngon lành” — đơn giản như truy cập một phần tử mảng.</p>
<aside name="fn">
<p>Trong chương này, biến local bắt đầu từ đáy mảng stack của VM và được đánh chỉ số từ đó. Khi ta thêm <a href="calls-and-functions.html">hàm</a>, sơ đồ này sẽ phức tạp hơn một chút. Mỗi hàm cần vùng stack riêng cho tham số và biến local của nó. Nhưng như ta sẽ thấy, điều đó không làm tăng nhiều độ phức tạp như bạn nghĩ.</p>
</aside>
<p>Có khá nhiều trạng thái mà ta cần phải theo dõi trong compiler để mọi thứ vận hành, nên hãy bắt đầu từ đây. Trong jlox, ta dùng một chuỗi liên kết các HashMap “environment” để theo dõi biến local nào đang nằm trong scope. Đây là cách khá kinh điển, kiểu “sách giáo khoa” để biểu diễn lexical scope. Với clox, như thường lệ, ta sẽ tiến gần hơn tới “kim loại” (low-level). Tất cả trạng thái sẽ nằm trong một struct mới.</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Local</span> <span class="i">locals</span>[<span class="a">UINT8_COUNT</span>];
  <span class="t">int</span> <span class="i">localCount</span>;
  <span class="t">int</span> <span class="i">scopeDepth</span>;
} <span class="t">Compiler</span>;
</pre><pre class="insert-after">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>Ta có một mảng phẳng, đơn giản chứa tất cả các biến local đang trong scope tại mỗi thời điểm trong quá trình compile. Chúng được <span name="order">sắp xếp</span> trong mảng theo thứ tự khai báo xuất hiện trong code. Vì toán hạng instruction mà ta dùng để mã hóa một biến local chỉ là một byte, VM của ta có một giới hạn cứng về số lượng biến local có thể cùng nằm trong scope. Điều đó cũng có nghĩa là ta có thể đặt kích thước cố định cho mảng locals.</p>
<aside name="order">
<p>Ta đang viết một compiler một-pass, nên cũng không có <em>quá</em> nhiều lựa chọn khác để sắp xếp chúng trong mảng.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert">

<span class="a">#define UINT8_COUNT (UINT8_MAX + 1)</span>
</pre><pre class="insert-after">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>

<p>Quay lại struct Compiler, trường <code>localCount</code> theo dõi số lượng biến local đang trong scope — tức là số slot trong mảng đang được dùng. Ta cũng theo dõi “scope depth”. Đây là số lượng block bao quanh đoạn code hiện tại đang compile.</p>
<p>Interpreter Java của ta dùng một chuỗi các map để tách biến của từng block khỏi các block khác. Lần này, ta sẽ đơn giản đánh số biến theo mức độ lồng nhau nơi chúng xuất hiện. Zero là global scope, một là block cấp cao nhất, hai là bên trong nó, bạn hiểu ý rồi đấy. Ta dùng thông tin này để biết mỗi biến local thuộc block nào, từ đó biết biến nào cần bỏ khi block kết thúc.</p>
<p>Mỗi biến local trong mảng là một struct như sau:</p>
<div class="codehilite"><pre class="insert-before">} ParseRule;
</pre><div class="source-file"><em>compiler.c</em><br>
add after struct <em>ParseRule</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">name</span>;
  <span class="t">int</span> <span class="i">depth</span>;
} <span class="t">Local</span>;
</pre><pre class="insert-after">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>ParseRule</em></div>

<p>Ta lưu tên của biến. Khi resolve một identifier, ta so sánh lexeme của identifier với tên của từng biến local để tìm khớp. Khá khó để resolve một biến nếu bạn không biết tên của nó. Trường <code>depth</code> ghi lại scope depth của block nơi biến local được khai báo. Đó là tất cả trạng thái ta cần lúc này.</p>
<p>Đây là một cách biểu diễn rất khác so với jlox, nhưng nó vẫn cho phép ta trả lời tất cả các câu hỏi mà compiler cần hỏi về lexical environment. Bước tiếp theo là tìm cách để compiler <em>truy cập</em> trạng thái này. Nếu là những kỹ sư <span name="thread">nguyên tắc</span>, ta sẽ truyền một tham số trỏ tới Compiler vào mỗi hàm ở front end. Ta sẽ tạo một Compiler lúc bắt đầu và cẩn thận “luồn” nó qua từng lời gọi hàm… nhưng điều đó sẽ đòi hỏi rất nhiều thay đổi nhàm chán vào code đã viết, nên thay vào đó, ta dùng một biến global:</p>
<aside name="thread">
<p>Đặc biệt, nếu ta muốn dùng compiler trong một ứng dụng đa luồng, có thể với nhiều compiler chạy song song, thì dùng biến global là một ý tưởng <em>tồi</em>.</p>
</aside>
<div class="codehilite"><pre class="insert-before">Parser parser;
</pre><div class="source-file"><em>compiler.c</em><br>
add after variable <em>parser</em></div>
<pre class="insert"><span class="t">Compiler</span>* <span class="i">current</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after">Chunk* compilingChunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>

<p>Đây là một hàm nhỏ để khởi tạo compiler:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>emitConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">localCount</span> = <span class="n">0</span>;
  <span class="i">compiler</span>-&gt;<span class="i">scopeDepth</span> = <span class="n">0</span>;
  <span class="i">current</span> = <span class="i">compiler</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>

<p>Khi VM khởi động lần đầu, ta gọi nó để đưa mọi thứ về trạng thái sạch.</p>
<div class="codehilite"><pre class="insert-before">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>compile</em>()</div>
<pre class="insert">  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>);
</pre><pre class="insert-after">  compilingChunk = chunk;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>

<p>Compiler của ta đã có dữ liệu cần thiết, nhưng chưa có thao tác trên dữ liệu đó. Chưa có cách để tạo và hủy scope, hoặc thêm và resolve biến. Ta sẽ bổ sung những thứ đó khi cần. Trước hết, hãy bắt đầu xây dựng một số tính năng ngôn ngữ.</p>
<h2><a href="#câu-lệnh-block" id="câu-lệnh-block"><small>22&#8202;.&#8202;2</small>Câu lệnh Block</a></h2>
<p>Trước khi có biến local, ta cần có local scope. Chúng đến từ hai thứ: thân hàm và <span name="block">block</span>. Hàm là một khối lượng công việc lớn mà ta sẽ xử lý trong <a href="functions">một chương sau</a>, nên bây giờ ta chỉ làm block. Như thường lệ, ta bắt đầu với cú pháp. Grammar mới sẽ là:</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">&quot;{&quot;</span> <span class="i">declaration</span>* <span class="s">&quot;}&quot;</span> ;
</pre></div>
<aside name="block">
<p>Nếu nghĩ kỹ, “block” là một cái tên kỳ lạ. Dùng theo nghĩa ẩn dụ, “block” thường chỉ một đơn vị nhỏ không thể chia, nhưng vì lý do nào đó, ủy ban Algol 60 lại dùng nó để chỉ một cấu trúc <em>hợp thành</em> — một chuỗi các câu lệnh. Có thể còn tệ hơn. Algol 58 gọi <code>begin</code> và <code>end</code> là “dấu ngoặc câu lệnh” (statement parentheses).</p><img src="image/local-variables/block.png" alt="Một viên gạch block." class="above" />
</aside>
<p>Block là một loại statement, nên rule cho nó nằm trong production <code>statement</code>. Code compile tương ứng trông như sau:</p>
<div class="codehilite"><pre class="insert-before">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>statement</em>()</div>
<pre class="insert">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_BRACE</span>)) {
    <span class="i">beginScope</span>();
    <span class="i">block</span>();
    <span class="i">endScope</span>();
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>

<p>Sau khi <span name="helper">parse</span> dấu ngoặc nhọn mở, ta dùng hàm helper này để compile phần còn lại của block:</p>
<aside name="helper">
<p>Hàm này sẽ rất hữu ích sau này khi compile thân hàm.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>expression</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">block</span>() {
  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after block.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>

<p>Hàm này tiếp tục parse các declaration và statement cho đến khi gặp dấu ngoặc nhọn đóng. Như với bất kỳ vòng lặp nào trong parser, ta cũng kiểm tra xem đã hết token chưa. Bằng cách này, nếu chương trình bị lỗi thiếu dấu ngoặc nhọn đóng, compiler sẽ không bị kẹt trong vòng lặp.</p>
<p>Execute một block đơn giản là execute các câu lệnh bên trong nó, lần lượt, nên compile chúng cũng không có gì phức tạp. Điều thú vị về mặt ngữ nghĩa mà block làm là tạo scope. Trước khi compile thân block, ta gọi hàm này để vào một local scope mới:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>endCompiler</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">beginScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>

<p>Để “tạo” một scope, tất cả những gì ta làm là tăng depth hiện tại. Cách này chắc chắn nhanh hơn jlox, vốn cấp phát hẳn một HashMap mới cho mỗi scope. Với <code>beginScope()</code>, bạn có thể đoán <code>endScope()</code> làm gì.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>beginScope</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">endScope</span>() {
  <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>--;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>beginScope</em>()</div>

<p>Vậy là xong phần block và scope — gần như thế — giờ ta đã sẵn sàng để đưa biến vào trong chúng.</p>
<h2><a href="#khai-báo-biến-local" id="khai-báo-biến-local"><small>22&#8202;.&#8202;3</small>Khai báo biến Local</a></h2>
<p>Thông thường ở đây ta sẽ bắt đầu với parsing, nhưng compiler của ta vốn đã hỗ trợ parse và compile khai báo biến. Ta đã có câu lệnh <code>var</code>, biểu thức identifier và gán giá trị. Chỉ là compiler hiện tại giả định tất cả biến đều là global. Vậy nên ta không cần thêm hỗ trợ parsing mới, chỉ cần kết nối ngữ nghĩa scoping mới vào code hiện có.</p><img src="image/local-variables/declaration.png" alt="Luồng code bên trong varDeclaration()." />
<p>Quá trình parse khai báo biến bắt đầu trong <code>varDeclaration()</code> và dựa vào một vài hàm khác. Đầu tiên, <code>parseVariable()</code> tiêu thụ token identifier cho tên biến, thêm lexeme của nó vào constant table của chunk dưới dạng string, rồi trả về chỉ số trong constant table nơi nó được thêm vào. Sau đó, khi <code>varDeclaration()</code> compile xong phần initializer, nó gọi <code>defineVariable()</code> để phát sinh bytecode lưu giá trị của biến vào bảng băm biến global.</p>
<p>Cả hai helper này cần một vài thay đổi để hỗ trợ biến local. Trong <code>parseVariable()</code>, ta thêm:</p>
<div class="codehilite"><pre class="insert-before">  consume(TOKEN_IDENTIFIER, errorMessage);
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>parseVariable</em>()</div>
<pre class="insert">

  <span class="i">declareVariable</span>();
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) <span class="k">return</span> <span class="n">0</span>;

</pre><pre class="insert-after">  return identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parseVariable</em>()</div>

<p>Trước hết, ta “declare” biến. Tôi sẽ giải thích “declare” nghĩa là gì ngay sau đây. Sau đó, nếu đang ở trong local scope, ta thoát khỏi hàm. Ở runtime, biến local không được tra cứu theo tên. Không cần nhét tên biến vào constant table, nên nếu khai báo nằm trong local scope, ta trả về một chỉ số giả trong bảng.</p>
<p>Bên phía <code>defineVariable()</code>, nếu đang ở trong local scope, ta cần phát sinh code để lưu biến local. Nó trông như thế này:</p>
<div class="codehilite"><pre class="insert-before">static void defineVariable(uint8_t global) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> &gt; <span class="n">0</span>) {
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  emitBytes(OP_DEFINE_GLOBAL, global);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Khoan, vậy thôi sao? Đúng vậy. Không có code nào để “tạo” biến local ở runtime cả. Hãy nghĩ về trạng thái của VM lúc này: nó đã execute xong code của phần initializer (hoặc <code>nil</code> ngầm định nếu người dùng bỏ qua initializer), và giá trị đó đang nằm trên đỉnh stack như temporary duy nhất còn lại. Ta cũng biết biến local mới được cấp phát ở đỉnh stack… đúng vị trí giá trị đó đang ở. Vậy nên chẳng cần làm gì thêm. Temporary đó đơn giản <em>trở thành</em> biến local. Khó mà hiệu quả hơn được nữa.</p>
<p><span name="locals"></span></p><img src="image/local-variables/local-slots.png" alt="Minh họa quá trình execute bytecode cho thấy kết quả của mỗi initializer nằm đúng vào slot của biến local." />
<aside name="locals">
<p>Code bên trái compile thành chuỗi instruction bên phải.</p>
</aside>
<p>OK, vậy “declare” ở đây là gì? Đây là những gì nó làm:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">declareVariable</span>() {
  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;

  <span class="t">Token</span>* <span class="i">name</span> = &amp;<span class="i">parser</span>.<span class="i">previous</span>;
  <span class="i">addLocal</span>(*<span class="i">name</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Đây là lúc compiler ghi nhận sự tồn tại của biến. Ta chỉ làm điều này cho biến local, nên nếu đang ở global scope cấp cao nhất, ta bỏ qua. Vì biến global là late bound, compiler không theo dõi các khai báo của chúng.</p>
<p>Nhưng với biến local, compiler cần nhớ rằng biến tồn tại. Đó chính là việc “declare” — thêm biến vào danh sách biến trong scope hiện tại của compiler. Ta hiện thực điều này bằng một hàm mới khác:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">addLocal</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Hàm này khởi tạo Local tiếp theo còn trống trong mảng biến của compiler. Nó lưu <span name="lexeme">tên</span> biến và độ sâu scope sở hữu biến đó.</p>
<aside name="lexeme">
<p>Lo lắng về vòng đời của string tên biến? Local lưu trực tiếp một bản sao struct Token của identifier. Token lưu con trỏ tới ký tự đầu tiên của lexeme và độ dài lexeme. Con trỏ này trỏ vào string nguồn gốc của script hoặc lệnh REPL đang compile.</p>
<p>Miễn là string đó tồn tại trong suốt quá trình compile — điều chắc chắn vì, bạn biết đấy, ta đang compile nó — thì tất cả token trỏ vào nó đều an toàn.</p>
</aside>
<p>Cách hiện thực này ổn với một chương trình Lox hợp lệ, nhưng còn code không hợp lệ thì sao? Ta nên hướng tới sự “chắc chắn”. Lỗi đầu tiên cần xử lý thực ra không phải lỗi của người dùng, mà là giới hạn của VM. Các instruction làm việc với biến local tham chiếu chúng bằng slot index. Chỉ số này được lưu trong một toán hạng một byte, nghĩa là VM chỉ hỗ trợ tối đa 256 biến local trong scope cùng lúc.</p>
<p>Nếu vượt quá, không chỉ không thể tham chiếu chúng ở runtime, mà compiler còn ghi đè chính mảng locals của nó. Hãy ngăn điều đó:</p>
<div class="codehilite"><pre class="insert-before">static void addLocal(Token name) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">&quot;Too many local variables in function.&quot;</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after">  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>

<p>Trường hợp tiếp theo phức tạp hơn. Xem ví dụ:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;first&quot;</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;second&quot;</span>;
}
</pre></div>
<p>Ở cấp cao nhất, Lox cho phép khai báo lại biến cùng tên với một khai báo trước đó vì điều này hữu ích cho REPL. Nhưng bên trong local scope, đó là một điều khá <span name="rust">kỳ quặc</span>. Nhiều khả năng đây là lỗi, và nhiều ngôn ngữ, bao gồm Lox của chúng ta, coi đây là lỗi.</p>
<aside name="rust">
<p>Thú vị là ngôn ngữ Rust <em>có</em> cho phép điều này, và code idiomatic của nó dựa vào đó.</p>
</aside>
<p>Lưu ý rằng chương trình trên khác với chương trình này:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;inner&quot;</span>;
  }
}
</pre></div>
<p>Việc có hai biến cùng tên trong <em>các scope khác nhau</em> là OK, ngay cả khi các scope này chồng lấn và cả hai cùng hiển thị tại một thời điểm. Đó là shadowing, và Lox cho phép. Chỉ khi có hai biến cùng tên trong <em>cùng</em> một local scope mới là lỗi.</p>
<p>Ta phát hiện lỗi này như sau:</p>
<div class="codehilite"><pre class="insert-before">  Token* name = &amp;parser.previous;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declareVariable</em>()</div>
<pre class="insert">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> != -<span class="n">1</span> &amp;&amp; <span class="i">local</span>-&gt;<span class="i">depth</span> &lt; <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
      <span class="k">break</span>;<span name="negative"> </span>
    }

    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="i">error</span>(<span class="s">&quot;Already a variable with this name in this scope.&quot;</span>);
    }
  }

</pre><pre class="insert-after">  addLocal(*name);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declareVariable</em>()</div>

<aside name="negative">
<p>Đừng lo về phần <code>depth != -1</code> kỳ lạ kia vội. Ta sẽ nói đến nó sau.</p>
</aside>
<p>Biến local được thêm vào cuối mảng khi chúng được khai báo, nghĩa là scope hiện tại luôn nằm ở cuối mảng. Khi ta khai báo một biến mới, ta bắt đầu từ cuối và duyệt ngược lại, tìm một biến đã tồn tại có cùng tên. Nếu tìm thấy một biến trong scope hiện tại, ta báo lỗi. Ngược lại, nếu ta đi đến đầu mảng hoặc gặp một biến thuộc scope khác, thì ta biết mình đã kiểm tra hết tất cả biến trong scope đó.</p>
<p>Để xem hai identifier có giống nhau không, ta dùng hàm sau:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifierConstant</em>()</div>
<pre><span class="k">static</span> <span class="t">bool</span> <span class="i">identifiersEqual</span>(<span class="t">Token</span>* <span class="i">a</span>, <span class="t">Token</span>* <span class="i">b</span>) {
  <span class="k">if</span> (<span class="i">a</span>-&gt;<span class="i">length</span> != <span class="i">b</span>-&gt;<span class="i">length</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">memcmp</span>(<span class="i">a</span>-&gt;<span class="i">start</span>, <span class="i">b</span>-&gt;<span class="i">start</span>, <span class="i">a</span>-&gt;<span class="i">length</span>) == <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifierConstant</em>()</div>

<p>Vì ta biết độ dài của cả hai lexeme, ta kiểm tra điều đó trước. Điều này sẽ loại nhanh nhiều chuỗi không bằng nhau. Nếu <span name="hash">độ dài</span> giống nhau, ta kiểm tra các ký tự bằng <code>memcmp()</code>. Để dùng <code>memcmp()</code>, ta cần include thêm.</p>
<aside name="hash">
<p>Sẽ là một tối ưu nhỏ hay ho nếu ta có thể so sánh hash của chúng, nhưng token không phải là LoxString đầy đủ, nên ta chưa tính hash cho chúng.</p>
</aside>
<div class="codehilite"><pre class="insert-before">#include &lt;stdlib.h&gt;
</pre><div class="source-file"><em>compiler.c</em></div>
<pre class="insert"><span class="a">#include &lt;string.h&gt;</span>
</pre><pre class="insert-after">

#include &quot;common.h&quot;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>

<p>Với điều này, ta đã có thể “tạo ra” biến. Nhưng giống như những bóng ma, chúng vẫn “lảng vảng” sau khi scope nơi chúng được khai báo đã kết thúc. Khi một block kết thúc, ta cần “an táng” chúng.</p>
<div class="codehilite"><pre class="insert-before">  current-&gt;scopeDepth--;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>endScope</em>()</div>
<pre class="insert">

  <span class="k">while</span> (<span class="i">current</span>-&gt;<span class="i">localCount</span> &gt; <span class="n">0</span> &amp;&amp;
         <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> &gt;
            <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>) {
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">current</span>-&gt;<span class="i">localCount</span>--;
  }
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>()</div>

<p>Khi ta pop một scope, ta duyệt ngược qua mảng local để tìm bất kỳ biến nào được khai báo ở scope depth vừa rời khỏi. Ta loại bỏ chúng đơn giản bằng cách giảm độ dài mảng.</p>
<p>Có một phần liên quan đến runtime ở đây. Biến local chiếm các slot trên stack. Khi một biến local ra khỏi scope, slot đó không còn cần thiết và nên được giải phóng. Vì vậy, với mỗi biến bị loại bỏ, ta cũng phát sinh một lệnh <code>OP_POP</code> <span name="pop"></span> để pop nó khỏi stack.</p>
<aside name="pop">
<p>Khi nhiều biến local ra khỏi scope cùng lúc, bạn sẽ có một loạt lệnh <code>OP_POP</code> được execute lần lượt. Một tối ưu đơn giản bạn có thể thêm vào Lox của mình là một lệnh chuyên biệt <code>OP_POPN</code> nhận một toán hạng cho số slot cần pop và pop tất cả cùng lúc.</p>
</aside>
<h2><a href="#sử-dụng-biến-local" id="sử-dụng-biến-local"><small>22&#8202;.&#8202;4</small>Sử dụng biến Local</a></h2>
<p>Giờ ta đã có thể compile và execute khai báo biến local. Ở runtime, giá trị của chúng nằm đúng vị trí trên stack. Hãy bắt đầu sử dụng chúng. Ta sẽ làm cả truy cập và gán biến cùng lúc vì chúng dùng chung các hàm trong compiler.</p>
<p>Ta đã có code để lấy và gán biến global, và — như những kỹ sư phần mềm tốt bụng — ta muốn tái sử dụng càng nhiều code hiện có càng tốt. Đại loại như thế này:</p>
<div class="codehilite"><pre class="insert-before">static void namedVariable(Token name, bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="t">uint8_t</span> <span class="i">getOp</span>, <span class="i">setOp</span>;
  <span class="t">int</span> <span class="i">arg</span> = <span class="i">resolveLocal</span>(<span class="i">current</span>, &amp;<span class="i">name</span>);
  <span class="k">if</span> (<span class="i">arg</span> != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_LOCAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_LOCAL</span>;
  } <span class="k">else</span> {
    <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
    <span class="i">getOp</span> = <span class="a">OP_GET_GLOBAL</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_GLOBAL</span>;
  }
</pre><pre class="insert-after">

  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Thay vì hardcode các bytecode instruction được phát sinh cho việc truy cập và gán biến, ta dùng một vài biến C. Đầu tiên, ta thử tìm một biến local với tên đã cho. Nếu tìm thấy, ta dùng instruction dành cho biến local. Nếu không, ta giả định đó là biến global và dùng instruction bytecode hiện có cho biến global.</p>
<p>Ngay bên dưới, ta dùng các biến đó để phát sinh instruction phù hợp. Với gán giá trị:</p>
<div class="codehilite"><pre class="insert-before">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">setOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Và với truy cập:</p>
<div class="codehilite"><pre class="insert-before">    emitBytes(setOp, (uint8_t)arg);
  } else {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>namedVariable</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="i">emitBytes</span>(<span class="i">getOp</span>, (<span class="t">uint8_t</span>)<span class="i">arg</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>

<p>Phần cốt lõi của chương này, nơi ta resolve một biến local, nằm ở đây:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>identifiersEqual</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">resolveLocal</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">compiler</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">locals</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">identifiersEqual</span>(<span class="i">name</span>, &amp;<span class="i">local</span>-&gt;<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>identifiersEqual</em>()</div>

<p>Nhìn chung, nó khá đơn giản. Ta duyệt danh sách các biến local hiện đang trong scope. Nếu một biến có cùng tên với token identifier, thì identifier đó chắc chắn tham chiếu tới biến này. Ta đã tìm thấy nó! Ta duyệt mảng ngược lại để tìm biến được khai báo <em>sau cùng</em> với identifier đó. Điều này đảm bảo rằng biến local bên trong sẽ shadow đúng cách biến local cùng tên ở scope bao ngoài.</p>
<p>Ở runtime, ta load và store biến local bằng chỉ số slot trên stack, nên đó là thứ compiler cần tính toán sau khi resolve biến. Mỗi khi một biến được khai báo, ta thêm nó vào mảng locals trong Compiler. Điều đó có nghĩa là biến local đầu tiên ở index 0, biến tiếp theo ở index 1, và cứ thế. Nói cách khác, mảng locals trong compiler có bố cục <em>chính xác</em> như stack của VM ở runtime. Chỉ số của biến trong mảng locals cũng chính là slot của nó trên stack. Thật tiện lợi!</p>
<p>Nếu ta duyệt hết mảng mà không tìm thấy biến có tên đã cho, thì chắc chắn nó không phải biến local. Trong trường hợp đó, ta trả về <code>-1</code> để báo rằng không tìm thấy và giả định nó là biến global.</p>
<h3><a href="#execute-biến-local" id="execute-biến-local"><small>22&#8202;.&#8202;4&#8202;.&#8202;1</small>Execute biến local</a></h3>
<p>Compiler của ta đang phát sinh hai instruction mới, nên hãy khiến chúng hoạt động. Đầu tiên là load một biến local:</p>
<div class="codehilite"><pre class="insert-before">  OP_POP,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Và phần hiện thực của nó:</p>
<div class="codehilite"><pre class="insert-before">      case OP_POP: pop(); break;
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>]);<span name="slot"> </span>
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nó nhận một toán hạng một byte cho slot trên stack nơi biến local nằm. Nó lấy giá trị từ chỉ số đó rồi push nó lên đỉnh stack để các instruction tiếp theo có thể tìm thấy.</p>
<aside name="slot">
<p>Có vẻ như việc push giá trị của biến local lên stack là dư thừa vì nó vốn đã nằm đâu đó thấp hơn trên stack. Vấn đề là các bytecode instruction khác chỉ tìm dữ liệu ở <em>đỉnh</em> stack. Đây là đặc điểm cốt lõi khiến tập lệnh bytecode của ta là dạng <em>stack</em>-based. Tập lệnh bytecode <a href="a-virtual-machine.html#design-note">register-based</a> tránh được việc “xoay” stack này, nhưng phải trả giá bằng các instruction lớn hơn với nhiều toán hạng hơn.</p>
</aside>
<p>Tiếp theo là gán giá trị:</p>
<div class="codehilite"><pre class="insert-before">  OP_GET_LOCAL,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_SET_LOCAL</span>,
</pre><pre class="insert-after">  OP_GET_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Chắc bạn cũng đoán được phần hiện thực.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">vm</span>.<span class="i">stack</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_GET_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nó lấy giá trị được gán từ đỉnh stack và lưu vào slot trên stack tương ứng với biến local. Lưu ý rằng nó không pop giá trị đó khỏi stack. Hãy nhớ rằng, gán là một biểu thức, và mọi biểu thức đều tạo ra một giá trị. Giá trị của một biểu thức gán chính là giá trị được gán, nên VM chỉ việc để nguyên giá trị đó trên stack.</p>
<p>Disassembler của ta sẽ chưa hoàn chỉnh nếu không hỗ trợ hai instruction mới này.</p>
<div class="codehilite"><pre class="insert-before">      return simpleInstruction(&quot;OP_POP&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_GET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_LOCAL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">&quot;OP_SET_LOCAL&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_GET_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Compiler compile biến local thành truy cập trực tiếp slot. Tên của biến local không bao giờ rời khỏi compiler để xuất hiện trong chunk. Điều này rất tốt cho hiệu năng, nhưng không tốt cho việc introspection. Khi disassemble các instruction này, ta không thể hiển thị tên biến như với biến global. Thay vào đó, ta chỉ hiển thị số slot.</p>
<aside name="debug">
<p>Việc xóa tên biến local trong compiler sẽ là một vấn đề thực sự nếu sau này ta muốn hiện thực debugger cho VM. Khi người dùng bước qua code, họ mong muốn thấy giá trị của các biến local được sắp xếp theo tên. Để hỗ trợ điều đó, ta sẽ cần xuất thêm thông tin bổ sung để theo dõi tên của từng biến local tại mỗi slot trên stack.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br>
add after <em>simpleInstruction</em>()</div>
<pre><span class="k">static</span> <span class="t">int</span> <span class="i">byteInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                           <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">&quot;%-16s %4d</span><span class="e">\n</span><span class="s">&quot;</span>, <span class="i">name</span>, <span class="i">slot</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;<span name="debug"> </span>
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>simpleInstruction</em>()</div>

<h3><a href="#một-edge-case-khác-về-scope" id="một-edge-case-khác-về-scope"><small>22&#8202;.&#8202;4&#8202;.&#8202;2</small>Một edge case khác về scope</a></h3>
<p>Ta đã dành thời gian xử lý một vài edge case kỳ lạ quanh scope. Ta đảm bảo shadowing hoạt động đúng. Ta báo lỗi nếu hai biến trong cùng một local scope có cùng tên. Vì lý do nào đó mà tôi cũng không hoàn toàn rõ, scoping của biến dường như luôn có nhiều “nếp nhăn” kiểu này. Tôi chưa từng thấy ngôn ngữ nào mà nó cảm giác hoàn toàn <span name="elegant">mượt mà</span>.</p>
<aside name="elegant">
<p>Không, kể cả Scheme.</p>
</aside>
<p>Ta còn một edge case nữa cần xử lý trước khi kết thúc chương này. Hãy nhớ lại “con quái vật” kỳ lạ mà ta từng gặp trong <a href="resolving-and-binding.html#resolving-variable-declarations">phần hiện thực variable resolution của jlox</a>:</p>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">&quot;outer&quot;</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
  }
}
</pre></div>
<p>Ta đã “hạ gục” nó khi đó bằng cách tách khai báo biến thành hai giai đoạn, và ta sẽ làm lại điều đó ở đây:</p><img src="image/local-variables/phases.png" alt="Ví dụ khai báo biến được đánh dấu 'declared uninitialized' trước tên biến và 'ready for use' sau phần initializer." />
<p>Ngay khi khai báo biến bắt đầu — tức là trước phần initializer — tên biến được khai báo trong scope hiện tại. Biến tồn tại, nhưng ở trạng thái đặc biệt “chưa khởi tạo”. Sau đó ta compile phần initializer. Nếu ở bất kỳ điểm nào trong biểu thức đó, ta resolve một identifier trỏ lại biến này, ta sẽ thấy nó chưa được khởi tạo và báo lỗi. Sau khi compile xong initializer, ta đánh dấu biến là đã khởi tạo và sẵn sàng sử dụng.</p>
<p>Để hiện thực điều này, khi khai báo một biến local, ta cần biểu thị trạng thái “chưa khởi tạo” bằng cách nào đó. Ta có thể thêm một trường mới vào Local, nhưng hãy tiết kiệm bộ nhớ hơn một chút. Thay vào đó, ta sẽ đặt scope depth của biến thành một giá trị sentinel đặc biệt, <code>-1</code>.</p>
<div class="codehilite"><pre class="insert-before">  local-&gt;name = name;
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>addLocal</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="i">local</span>-&gt;<span class="i">depth</span> = -<span class="n">1</span>;
</pre><pre class="insert-after">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>(), replace 1 line</div>

<p>Sau đó, khi phần initializer của biến đã được compile, ta đánh dấu nó là đã khởi tạo.</p>
<div class="codehilite"><pre class="insert-before">  if (current-&gt;scopeDepth &gt; 0) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>defineVariable</em>()</div>
<pre class="insert">    <span class="i">markInitialized</span>();
</pre><pre class="insert-after">    return;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>defineVariable</em>()</div>

<p>Phần này được hiện thực như sau:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>parseVariable</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">markInitialized</span>() {
  <span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">depth</span> =
      <span class="i">current</span>-&gt;<span class="i">scopeDepth</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>

<p>Vậy đây mới <em>thực sự</em> là ý nghĩa của “declare” và “define” một biến trong compiler. “Declare” là khi biến được thêm vào scope, và “define” là khi nó sẵn sàng để sử dụng.</p>
<p>Khi ta resolve một tham chiếu tới biến local, ta kiểm tra scope depth để xem nó đã được định nghĩa đầy đủ chưa.</p>
<div class="codehilite"><pre class="insert-before">    if (identifiersEqual(name, &amp;local-&gt;name)) {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>resolveLocal</em>()</div>
<pre class="insert">      <span class="k">if</span> (<span class="i">local</span>-&gt;<span class="i">depth</span> == -<span class="n">1</span>) {
        <span class="i">error</span>(<span class="s">&quot;Can&#39;t read local variable in its own initializer.&quot;</span>);
      }
</pre><pre class="insert-after">      return i;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveLocal</em>()</div>

<p>Nếu biến có depth là giá trị sentinel, thì chắc chắn đó là một tham chiếu tới biến trong chính initializer của nó, và ta báo lỗi.</p>
<p>Vậy là xong chương này! Ta đã thêm block, biến local, và lexical scoping “xịn”. Mặc dù ta đã giới thiệu một cách biểu diễn biến ở runtime hoàn toàn khác, nhưng lượng code phải viết không nhiều. Phần hiện thực cuối cùng khá gọn gàng và hiệu quả.</p>
<p>Bạn sẽ nhận thấy gần như toàn bộ code ta viết nằm ở compiler. Còn ở runtime, chỉ có hai instruction nhỏ. Bạn sẽ thấy đây là một <span name="static">xu hướng</span> tiếp diễn trong clox so với jlox. Một trong những “vũ khí” lớn nhất trong hộp công cụ của optimizer là kéo công việc về phía compiler để không phải làm ở runtime. Trong chương này, điều đó có nghĩa là resolve chính xác slot trên stack mà mỗi biến local chiếm. Nhờ vậy, ở runtime, không cần lookup hay resolve gì nữa.</p>
<aside name="static">
<p>Bạn có thể xem static type như một ví dụ cực đoan của xu hướng này. Một ngôn ngữ có kiểu tĩnh sẽ thực hiện toàn bộ việc phân tích kiểu và xử lý lỗi kiểu ngay trong quá trình biên dịch. Nhờ đó, runtime không phải tốn thời gian kiểm tra xem giá trị có đúng kiểu cho phép với phép toán hay không. Thực tế, trong một số ngôn ngữ kiểu tĩnh như C, bạn thậm chí còn <em>không biết</em> kiểu của giá trị ở runtime. Compiler sẽ xóa hoàn toàn mọi thông tin biểu diễn kiểu của giá trị, chỉ để lại phần bit thuần túy.</p>
</aside>
<div class="challenges">
<h2><a href="#thử-thách" id="thử-thách"><small>22&#8202;.&#8202;5</small>Thử thách</a></h2>
<ol>
<li>
<p>Mảng local đơn giản của ta giúp việc tính toán stack slot của mỗi biến local trở nên dễ dàng. Nhưng điều đó cũng có nghĩa là khi compiler resolve một tham chiếu tới biến, ta phải quét tuyến tính qua mảng.</p>
<p>Hãy nghĩ ra một cách hiệu quả hơn. Bạn có cho rằng độ phức tạp tăng thêm là xứng đáng không?</p>
</li>
<li>
<p>Các ngôn ngữ khác xử lý đoạn code như thế này thế nào:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
</pre></div>
<p>Nếu đây là ngôn ngữ của bạn, bạn sẽ làm gì? Tại sao?</p>
</li>
<li>
<p>Nhiều ngôn ngữ phân biệt giữa biến có thể gán lại và biến không thể gán lại. Trong Java, từ khóa <code>final</code> ngăn bạn gán lại cho biến. Trong JavaScript, biến khai báo bằng <code>let</code> có thể gán lại, nhưng biến khai báo bằng <code>const</code> thì không. Swift coi <code>let</code> là biến chỉ gán một lần và dùng <code>var</code> cho biến có thể gán lại. Scala và Kotlin dùng <code>val</code> và <code>var</code>.</p>
<p>Hãy chọn một từ khóa cho dạng biến chỉ gán một lần để thêm vào Lox. Giải thích lý do chọn, rồi hiện thực nó. Nếu cố gán cho một biến được khai báo bằng từ khóa mới này, compiler phải báo lỗi.</p>
</li>
<li>
<p>Mở rộng clox để cho phép nhiều hơn 256 biến local cùng nằm trong scope tại một thời điểm.</p>
</li>
</ol>
</div>

<footer>
<a href="jumping-back-and-forth.html" class="next">
  Đọc tiếp Chapter: &ldquo;Jumping Back and Forth&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
