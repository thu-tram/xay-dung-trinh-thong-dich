<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Classes and Instances &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Classes and Instances<small>27</small></a></h3>

<ul>
    <li><a href="#class-objects"><small>27.1</small> Class Objects</a></li>
    <li><a href="#class-declarations"><small>27.2</small> Class Declarations</a></li>
    <li><a href="#instance-của-class"><small>27.3</small> Instance của Class</a></li>
    <li><a href="#biểu-thức-get-&amp;-set"><small>27.4</small> Biểu thức Get &amp; Set</a></li>
    <li><a href="#thử-thách"><small>27.5</small> Thử thách</a></li>
</ul>


<div class="prev-next">
    <a href="garbage-collection.html" title="Garbage Collection" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="methods-and-initializers.html" title="Methods and Initializers" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="garbage-collection.html" title="Garbage Collection" class="prev">←</a>
<a href="methods-and-initializers.html" title="Methods and Initializers" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Classes and Instances<small>27</small></a></h3>

<ul>
    <li><a href="#class-objects"><small>27.1</small> Class Objects</a></li>
    <li><a href="#class-declarations"><small>27.2</small> Class Declarations</a></li>
    <li><a href="#instance-của-class"><small>27.3</small> Instance của Class</a></li>
    <li><a href="#biểu-thức-get-&amp;-set"><small>27.4</small> Biểu thức Get &amp; Set</a></li>
    <li><a href="#thử-thách"><small>27.5</small> Thử thách</a></li>
</ul>


<div class="prev-next">
    <a href="garbage-collection.html" title="Garbage Collection" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="methods-and-initializers.html" title="Methods and Initializers" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">27</div>
  <h1>Classes and Instances</h1>

<blockquote>
<p>Quan tâm quá nhiều đến đồ vật có thể hủy hoại bạn. Nhưng — nếu bạn quan tâm đến một thứ đủ nhiều, nó sẽ có một “cuộc sống” riêng, đúng không? Và chẳng phải ý nghĩa của mọi thứ — những thứ đẹp đẽ — là chúng kết nối bạn với một vẻ đẹp lớn hơn sao?</p>
<p><cite>Donna Tartt, <em>The Goldfinch</em></cite></p>
</blockquote>
<p>Phần cuối cùng còn lại để cài đặt trong clox là lập trình hướng đối tượng. <span name="oop">OOP</span> là một gói các tính năng đan xen nhau: class, instance, field, method, initializer, và inheritance. Khi dùng Java — một ngôn ngữ bậc cao hơn — chúng ta gói gọn tất cả trong hai chương. Giờ đây, khi lập trình bằng C, cảm giác như đang dựng mô hình tháp Eiffel bằng… tăm xỉa răng, chúng ta sẽ dành hẳn ba chương để bao quát cùng một phạm vi. Điều này cho phép chúng ta thong thả hơn khi triển khai. Sau những chương “nặng đô” như <a href="closures.html">closures</a> và <a href="garbage-collection.html">garbage collector</a>, bạn xứng đáng được nghỉ ngơi. Thực tế, từ đây trở đi, cuốn sách sẽ dễ hơn nhiều.</p>
<aside name="oop">
<p>Những người có quan điểm mạnh mẽ về lập trình hướng đối tượng — tức là “ai cũng vậy” — thường cho rằng OOP đồng nghĩa với một danh sách rất cụ thể các tính năng ngôn ngữ. Nhưng thực ra, đây là một không gian rộng để khám phá, và mỗi ngôn ngữ lại có “nguyên liệu” và “công thức” riêng.</p>
<p>Self có object nhưng không có class. CLOS có method nhưng không gắn chúng với class cụ thể. C++ ban đầu không có runtime polymorphism — không có virtual method. Python có multiple inheritance, nhưng Java thì không. Ruby gắn method vào class, nhưng bạn cũng có thể định nghĩa method cho một object đơn lẻ.</p>
</aside>
<p>Trong chương này, chúng ta sẽ triển khai ba tính năng đầu tiên: class, instance, và field. Đây là phần “có trạng thái” của hướng đối tượng. Sau đó, trong hai chương tiếp theo, chúng ta sẽ gắn hành vi và khả năng tái sử dụng code vào các object này.</p>
<h2><a href="#class-objects" id="class-objects"><small>27&#8202;.&#8202;1</small>Class Objects</a></h2>
<p>Trong một ngôn ngữ hướng đối tượng dựa trên class, mọi thứ bắt đầu từ class. Chúng định nghĩa loại object nào tồn tại trong chương trình và là “nhà máy” tạo ra các instance mới. Đi từ dưới lên, chúng ta sẽ bắt đầu với cách biểu diễn chúng ở runtime, rồi kết nối nó vào ngôn ngữ.</p>
<p>Đến giờ, chúng ta đã quen với quy trình thêm một loại object mới vào VM. Ta bắt đầu với một struct.</p>
<div class="codehilite"><pre class="insert-before">} ObjClosure;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClosure</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjClass</span>;
</pre><pre class="insert-after">

ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>

<p>Sau phần header Obj, chúng ta lưu tên của class. Điều này không thực sự cần thiết cho chương trình của người dùng, nhưng nó cho phép chúng ta hiển thị tên ở runtime, ví dụ như trong stack trace.</p>
<p>Loại mới này cần một case tương ứng trong enum ObjType.</p>
<div class="codehilite"><pre class="insert-before">typedef enum {
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_CLASS</span>,
</pre><pre class="insert-after">  OBJ_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Và loại này cũng cần một cặp macro tương ứng. Đầu tiên, để kiểm tra kiểu của một object:</p>
<div class="codehilite"><pre class="insert-before">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)</span>
</pre><pre class="insert-after">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Và sau đó là để cast một Value thành con trỏ ObjClass:</p>
<div class="codehilite"><pre class="insert-before">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>VM tạo class object mới bằng hàm sau:</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;

</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert"><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>);
</pre><pre class="insert-after">ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>Phần cài đặt nằm ở đây:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClass</span>, <span class="a">OBJ_CLASS</span>);
  <span class="i">klass</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;<span name="klass"> </span>
  <span class="k">return</span> <span class="i">klass</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Hầu hết chỉ là code mẫu. Hàm nhận tên class dưới dạng string và lưu lại. Mỗi khi người dùng khai báo một class mới, VM sẽ tạo một ObjClass struct mới để biểu diễn nó.</p>
<aside name="klass"><img src="image/classes-and-instances/klass.png" alt="'Klass' in a zany kidz font."/>
<p>Tôi đặt tên biến là “klass” không chỉ để tạo cảm giác “Kidz Korner” vui nhộn cho VM. Nó còn giúp việc biên dịch clox bằng C++ dễ dàng hơn, vì “class” là từ khóa trong C++.</p>
</aside>
<p>Khi VM không còn cần class nữa, nó sẽ giải phóng như sau:</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClass</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }<span name="braces"> </span>
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<aside name="braces">
<p>Dấu ngoặc ở đây hiện tại chưa cần thiết, nhưng sẽ hữu ích trong chương sau khi chúng ta thêm code vào nhánh switch case này.</p>
</aside>
<p>Giờ chúng ta đã có bộ quản lý bộ nhớ, nên cũng cần hỗ trợ việc “tracing” qua các class object.</p>
<div class="codehilite"><pre class="insert-before">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">klass</span>-&gt;<span class="i">name</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Khi GC gặp một class object, nó sẽ đánh dấu tên class để giữ cho string đó không bị giải phóng.</p>
<p>Thao tác cuối cùng mà VM có thể thực hiện trên một class là in ra nó.</p>
<div class="codehilite"><pre class="insert-before">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s&quot;</span>, <span class="a">AS_CLASS</span>(<span class="i">value</span>)-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>Một class chỉ đơn giản là in ra tên của chính nó.</p>
<h2><a href="#class-declarations" id="class-declarations"><small>27&#8202;.&#8202;2</small>Class Declarations</a></h2>
<p>Khi đã có cách biểu diễn ở runtime, chúng ta sẵn sàng thêm hỗ trợ cho class vào ngôn ngữ. Tiếp theo, ta chuyển sang parser.</p>
<div class="codehilite"><pre class="insert-before">static void declaration() {
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_CLASS</span>)) {
    <span class="i">classDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
</pre><pre class="insert-after">    funDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>Khai báo class là một statement, và parser nhận diện nó bằng từ khóa <code>class</code> ở đầu. Phần compile còn lại diễn ra ở đây:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>function</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">classDeclaration</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect class name.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">nameConstant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">declareVariable</span>();

  <span class="i">emitBytes</span>(<span class="a">OP_CLASS</span>, <span class="i">nameConstant</span>);
  <span class="i">defineVariable</span>(<span class="i">nameConstant</span>);

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>

<p>Ngay sau từ khóa <code>class</code> là tên class. Chúng ta lấy identifier đó và thêm vào constant table của hàm bao quanh dưới dạng string. Như bạn vừa thấy, in ra một class sẽ hiển thị tên của nó, nên compiler cần lưu string tên này ở nơi mà runtime có thể tìm thấy. Constant table chính là cách để làm điều đó.</p>
<p>Tên <span name="variable">class</span> này cũng được dùng để gán class object vào một biến cùng tên. Vì vậy, ngay sau khi đọc token tên class, ta khai báo một biến với identifier đó.</p>
<aside name="variable">
<p>Chúng ta hoàn toàn có thể thiết kế để khai báo class là <em>biểu thức</em> thay vì statement — về bản chất, chúng cũng giống như một literal tạo ra một giá trị. Khi đó, người dùng sẽ phải tự gán class vào một biến, ví dụ:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="t">Pie</span> = <span class="k">class</span> {}
</pre></div>
<p>Giống như lambda function nhưng dành cho class. Tuy nhiên, vì chúng ta thường muốn class có tên, nên hợp lý hơn khi coi chúng là một dạng khai báo.</p>
</aside>
<p>Tiếp theo, chúng ta sinh ra một instruction mới để thực sự tạo class object tại runtime. Instruction này nhận chỉ số trong constant table của tên class làm operand.</p>
<p>Sau đó, nhưng trước khi compile phần thân class, chúng ta define biến cho tên class. <em>Khai báo</em> biến sẽ thêm nó vào scope, nhưng nhớ lại từ <a href="local-variables.html#another-scope-edge-case">một chương trước</a> rằng ta không thể <em>dùng</em> biến cho đến khi nó được <em>define</em>. Với class, ta define biến trước phần thân. Cách này cho phép người dùng tham chiếu đến class chứa nó ngay bên trong các method của chính nó. Điều này hữu ích cho những thứ như factory method tạo ra instance mới của class.</p>
<p>Cuối cùng, chúng ta compile phần thân. Hiện tại chưa có method, nên nó chỉ đơn giản là một cặp dấu ngoặc nhọn rỗng. Lox không yêu cầu khai báo field trong class, nên ta tạm xong phần thân — và cả parser — ở đây.</p>
<p>Compiler đang sinh ra một instruction mới, vậy hãy định nghĩa nó.</p>
<div class="codehilite"><pre class="insert-before">  OP_RETURN,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_CLASS</span>,
</pre><pre class="insert-after">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Và thêm nó vào disassembler:</p>
<div class="codehilite"><pre class="insert-before">    case OP_RETURN:
      return simpleInstruction(&quot;OP_RETURN&quot;, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_CLASS</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_CLASS&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>Với một tính năng trông có vẻ “to lớn” như vậy, phần hỗ trợ trong interpreter lại rất tối giản.</p>
<div class="codehilite"><pre class="insert-before">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_CLASS</span>:
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newClass</span>(<span class="a">READ_STRING</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Chúng ta load string tên class từ constant table và truyền nó vào <code>newClass()</code>. Hàm này tạo một class object mới với tên đã cho. Ta push object đó lên stack và xong. Nếu class được gán vào một biến global, thì lời gọi <code>defineVariable()</code> của compiler sẽ sinh code để lưu object đó từ stack vào bảng biến global. Nếu không, nó đã nằm đúng vị trí trên stack để dùng cho một biến <span name="local">local</span> mới.</p>
<aside name="local">
<p>Class “local” — class được khai báo bên trong thân hàm hoặc block — là một khái niệm khá lạ. Nhiều ngôn ngữ không cho phép điều này. Nhưng vì Lox là một ngôn ngữ scripting kiểu dynamic, nó xử lý phần top-level của chương trình và thân hàm/block theo cùng một cách. Class chỉ là một dạng khai báo khác, và vì bạn có thể khai báo biến và hàm bên trong block, bạn cũng có thể khai báo class ở đó.</p>
</aside>
<p>Vậy là xong, VM của chúng ta giờ đã hỗ trợ class. Bạn có thể chạy:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>;
</pre></div>
<p>Tiếc là hiện tại in ra gần như là <em>tất cả</em> những gì bạn có thể làm với class, nên bước tiếp theo là làm cho chúng hữu ích hơn.</p>
<h2><a href="#instance-của-class" id="instance-của-class"><small>27&#8202;.&#8202;3</small>Instance của Class</a></h2>
<p>Class có hai mục đích chính trong một ngôn ngữ:</p>
<ul>
<li>
<p><strong>Chúng là cách để tạo instance mới.</strong> Đôi khi điều này liên quan đến từ khóa <code>new</code>, đôi khi là một lời gọi method trên class object, nhưng thường bạn sẽ nhắc đến class bằng tên <em>nào đó</em> để tạo instance mới.</p>
</li>
<li>
<p><strong>Chúng chứa method.</strong> Đây là nơi định nghĩa cách tất cả instance của class hoạt động.</p>
</li>
</ul>
<p>Chúng ta sẽ chưa bàn đến method cho đến chương sau, nên bây giờ chỉ tập trung vào phần đầu tiên. Trước khi class có thể tạo instance, chúng ta cần một cách biểu diễn chúng.</p>
<div class="codehilite"><pre class="insert-before">} ObjClass;
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjClass</span>* <span class="i">klass</span>;
  <span class="t">Table</span> <span class="i">fields</span>;<span name="fields"> </span>
} <span class="t">ObjInstance</span>;
</pre><pre class="insert-after">

ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>Instance biết class của mình — mỗi instance có một con trỏ tới class mà nó là instance của. Chúng ta sẽ chưa dùng nhiều trong chương này, nhưng nó sẽ trở nên quan trọng khi thêm method.</p>
<p>Quan trọng hơn trong chương này là cách instance lưu trữ trạng thái. Lox cho phép người dùng tự do thêm field vào instance tại runtime. Điều này có nghĩa là ta cần một cơ chế lưu trữ có thể mở rộng. Ta có thể dùng mảng động, nhưng ta cũng muốn tra cứu field theo tên càng nhanh càng tốt. Có một cấu trúc dữ liệu hoàn hảo cho việc truy cập nhanh một tập giá trị theo tên và — tiện hơn nữa — chúng ta đã cài đặt nó rồi. Mỗi instance lưu field của mình bằng một hash table.</p>
<aside name="fields">
<p>Khả năng tự do thêm field vào object tại runtime là một khác biệt lớn về mặt thực tiễn giữa hầu hết ngôn ngữ dynamic và static. Ngôn ngữ static thường yêu cầu field phải được khai báo rõ ràng. Cách này giúp compiler biết chính xác mỗi instance có những field nào. Nó có thể dùng thông tin đó để xác định chính xác lượng bộ nhớ cần cho mỗi instance và offset trong bộ nhớ nơi mỗi field được lưu.</p>
<p>Trong Lox và các ngôn ngữ dynamic khác, việc truy cập field thường là một thao tác tra cứu hash table. Thời gian hằng số, nhưng vẫn khá “nặng”. Trong một ngôn ngữ như C++, truy cập field nhanh như việc cộng một offset hằng số vào con trỏ.</p>
</aside>
<p>Chúng ta chỉ cần thêm một include, và xong.</p>
<div class="codehilite"><pre class="insert-before">#include &quot;chunk.h&quot;
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#include &quot;table.h&quot;</span>
</pre><pre class="insert-after">#include &quot;value.h&quot;
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Struct mới này có một object type mới.</p>
<div class="codehilite"><pre class="insert-before">  OBJ_FUNCTION,
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert">  <span class="a">OBJ_INSTANCE</span>,
</pre><pre class="insert-after">  OBJ_NATIVE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>Tôi muốn chậm lại một chút ở đây vì khái niệm “type” trong <em>ngôn ngữ</em> Lox và khái niệm “type” trong <em>cài đặt</em> VM có thể gây nhầm lẫn. Trong code C tạo nên clox, có nhiều loại Obj khác nhau — ObjString, ObjClosure, v.v. Mỗi loại có cách biểu diễn nội bộ và ngữ nghĩa riêng.</p>
<p>Trong <em>ngôn ngữ</em> Lox, người dùng có thể định nghĩa class của riêng mình — ví dụ Cake và Pie — rồi tạo instance của các class đó. Từ góc nhìn của người dùng, một instance của Cake là một loại object khác với một instance của Pie. Nhưng từ góc nhìn của VM, mỗi class mà người dùng định nghĩa chỉ đơn giản là một giá trị khác của kiểu ObjClass. Tương tự, mỗi instance trong chương trình của người dùng, bất kể thuộc class nào, đều là một ObjInstance. Một loại object của VM bao quát instance của mọi class. Hai “thế giới” này ánh xạ với nhau như sau:</p><img src="image/classes-and-instances/lox-clox.png" alt="Một tập các khai báo class và instance, và cách biểu diễn runtime mà mỗi cái ánh xạ tới."/>
<p>Rõ chưa? OK, quay lại phần cài đặt. Chúng ta cũng có các macro quen thuộc.</p>
<div class="codehilite"><pre class="insert-before">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define IS_INSTANCE(value)     isObjType(value, OBJ_INSTANCE)</span>
</pre><pre class="insert-after">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Và:</p>
<div class="codehilite"><pre class="insert-before">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span class="a">#define AS_INSTANCE(value)     ((ObjInstance*)AS_OBJ(value))</span>
</pre><pre class="insert-after">#define AS_NATIVE(value) \
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>

<p>Vì field được thêm sau khi instance được tạo, hàm “constructor” chỉ cần biết class.</p>
<div class="codehilite"><pre class="insert-before">ObjFunction* newFunction();
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>);
</pre><pre class="insert-after">ObjNative* newNative(NativeFn function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>Chúng ta cài đặt hàm này ở đây:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>) {
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjInstance</span>, <span class="a">OBJ_INSTANCE</span>);
  <span class="i">instance</span>-&gt;<span class="i">klass</span> = <span class="i">klass</span>;
  <span class="i">initTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
  <span class="k">return</span> <span class="i">instance</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>Ta lưu một tham chiếu tới class của instance. Sau đó khởi tạo bảng field thành một hash table rỗng. Một “em bé” object mới ra đời!</p>
<p>Ở “đầu bên kia” buồn hơn của vòng đời instance, nó sẽ bị giải phóng.</p>
<div class="codehilite"><pre class="insert-before">      FREE(ObjFunction, object);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="a">FREE</span>(<span class="t">ObjInstance</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>Instance sở hữu bảng field của nó, nên khi giải phóng instance, ta cũng giải phóng bảng này. Ta không giải phóng trực tiếp các entry <em>bên trong</em> bảng, vì có thể vẫn còn tham chiếu khác tới các object đó. Garbage collector sẽ lo phần này cho chúng ta. Ở đây, ta chỉ giải phóng mảng entry của chính bảng.</p>
<p>Nói đến garbage collector, nó cũng cần hỗ trợ việc “tracing” qua các instance.</p>
<div class="codehilite"><pre class="insert-before">      markArray(&amp;function-&gt;chunk.constants);
      break;
    }
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">instance</span>-&gt;<span class="i">klass</span>);
      <span class="i">markTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>Nếu instance còn sống, ta cần giữ lại class của nó. Đồng thời, ta cũng cần giữ lại mọi object được tham chiếu bởi các field của instance. Hầu hết các object còn sống nhưng không phải root đều có thể truy cập được vì có một instance nào đó tham chiếu tới chúng qua field. May mắn là ta đã có sẵn hàm <code>markTable()</code> tiện lợi để việc tracing này trở nên dễ dàng.</p>
<p>Ít quan trọng hơn nhưng vẫn cần thiết là việc in ra.</p>
<div class="codehilite"><pre class="insert-before">      break;
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>:
      <span class="i">printf</span>(<span class="s">&quot;%s instance&quot;</span>,
             <span class="a">AS_INSTANCE</span>(<span class="i">value</span>)-&gt;<span class="i">klass</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p><span name="print">Một</span> instance sẽ in ra tên của nó kèm theo chữ “instance”. (Phần “instance” chủ yếu để class và instance không in ra giống hệt nhau.)</p>
<aside name="print">
<p>Hầu hết các ngôn ngữ hướng đối tượng cho phép class định nghĩa một dạng method <code>toString()</code> để chỉ định cách các instance của nó được chuyển thành chuỗi và in ra. Nếu Lox bớt “đồ chơi” hơn, tôi cũng muốn hỗ trợ điều đó.</p>
</aside>
<p>Phần thú vị thực sự diễn ra ở interpreter. Lox không có từ khóa <code>new</code> đặc biệt. Cách để tạo một instance của class là gọi chính class đó như thể nó là một hàm. Runtime đã hỗ trợ lời gọi hàm, và nó kiểm tra kiểu của object được gọi để đảm bảo người dùng không cố gọi một số hoặc kiểu không hợp lệ khác.</p>
<p>Chúng ta mở rộng phần kiểm tra runtime đó với một case mới.</p>
<div class="codehilite"><pre class="insert-before">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
        <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">callee</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="a">OBJ_VAL</span>(<span class="i">newInstance</span>(<span class="i">klass</span>));
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after">      case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>Nếu giá trị được gọi — object thu được khi đánh giá biểu thức bên trái dấu ngoặc đơn mở — là một class, thì ta xử lý nó như một lời gọi constructor. Ta <span name="args">tạo</span> một instance mới của class được gọi và lưu kết quả lên stack.</p>
<aside name="args">
<p>Hiện tại, ta bỏ qua mọi argument được truyền vào lời gọi. Chúng ta sẽ quay lại đoạn code này trong <a href="methods-and-initializers.html">chương tiếp theo</a> khi thêm hỗ trợ cho initializer.</p>
</aside>
<p>Chúng ta đã tiến thêm một bước. Giờ ta có thể định nghĩa class và tạo instance của chúng.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>();
</pre></div>
<p>Lưu ý dấu ngoặc đơn sau <code>Brioche</code> ở dòng thứ hai. Lệnh này sẽ in ra<br />
“Brioche instance”.</p>
<h2><a href="#biểu-thức-get-&-set" id="biểu-thức-get-&-set"><small>27&#8202;.&#8202;4</small>Biểu thức Get &amp; Set</a></h2>
<p>Cách biểu diễn object cho instance của chúng ta đã có thể lưu trữ trạng thái, nên việc còn lại chỉ là cung cấp chức năng đó cho người dùng. Field được truy cập và thay đổi thông qua các biểu thức get và set. Giữ truyền thống, Lox dùng cú pháp “dấu chấm” kinh điển:</p>
<div class="codehilite"><pre><span class="i">eclair</span>.<span class="i">filling</span> = <span class="s">&quot;pastry creme&quot;</span>;
<span class="k">print</span> <span class="i">eclair</span>.<span class="i">filling</span>;
</pre></div>
<p>Dấu chấm — hay “full stop” cho các bạn nói tiếng Anh — hoạt động <span name="sort">gần giống</span> như một toán tử infix. Có một biểu thức ở bên trái được đánh giá trước và tạo ra một instance. Sau đó là dấu <code>.</code> và một tên field. Vì có một toán hạng đứng trước, ta gắn nó vào bảng parse như một biểu thức infix.</p>
<aside name="sort">
<p>Tôi nói “gần giống” vì phần bên phải sau dấu <code>.</code> không phải là một biểu thức, mà là một identifier duy nhất, có ngữ nghĩa được xử lý bởi chính biểu thức get hoặc set. Thực ra nó gần giống một biểu thức postfix hơn.</p>
</aside>
<div class="codehilite"><pre class="insert-before">  [TOKEN_COMMA]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert">  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="i">dot</span>,    <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after">  [TOKEN_MINUS]         = {unary,    binary, PREC_TERM},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>Giống như các ngôn ngữ khác, toán tử <code>.</code> có độ ưu tiên cao, ngang với dấu ngoặc đơn trong lời gọi hàm. Sau khi parser đọc token dấu chấm, nó sẽ chuyển sang một hàm parse mới.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>call</em>()</div>
<pre><span class="k">static</span> <span class="t">void</span> <span class="i">dot</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span>);
  <span class="t">uint8_t</span> <span class="i">name</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_PROPERTY</span>, <span class="i">name</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_PROPERTY</span>, <span class="i">name</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>call</em>()</div>

<p>Parser mong đợi tìm thấy một tên <span name="prop">property</span> ngay sau dấu chấm. Ta nạp lexeme của token đó vào constant table dưới dạng string để tên này có thể được truy cập ở runtime.</p>
<aside name="prop">
<p>Compiler dùng “property” thay vì “field” ở đây vì, nhớ rằng, Lox cũng cho phép bạn dùng cú pháp dấu chấm để truy cập một method mà không gọi nó. “Property” là thuật ngữ chung để chỉ bất kỳ thực thể có tên nào bạn có thể truy cập trên một instance. Field là tập con của property, được hỗ trợ bởi trạng thái của instance.</p>
</aside>
<p>Chúng ta có hai dạng biểu thức mới — getter và setter — và cả hai đều được xử lý trong cùng một hàm này. Nếu thấy dấu bằng ngay sau tên field, chắc chắn đó là một biểu thức set, gán giá trị cho field. Nhưng ta không phải lúc nào cũng <em>cho phép</em> compile dấu bằng sau field. Xem ví dụ:</p>
<div class="codehilite"><pre><span class="i">a</span> + <span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>
</pre></div>
<p>Theo grammar của Lox, đây là cú pháp không hợp lệ, nghĩa là bản cài đặt Lox của chúng ta bắt buộc phải phát hiện và báo lỗi. Nếu <code>dot()</code> âm thầm parse phần <code>= 3</code>, chúng ta sẽ diễn giải sai code như thể người dùng đã viết:</p>
<div class="codehilite"><pre><span class="i">a</span> + (<span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>)
</pre></div>
<p>Vấn đề là phía <code>=</code> của một biểu thức set có độ ưu tiên thấp hơn nhiều so với phần <code>.</code>. Parser có thể gọi <code>dot()</code> trong một ngữ cảnh có độ ưu tiên quá cao để cho phép setter xuất hiện. Để tránh việc cho phép sai, ta chỉ parse và compile phần dấu bằng khi <code>canAssign</code> là true. Nếu gặp token dấu bằng khi <code>canAssign</code> là false, <code>dot()</code> sẽ bỏ qua và trả về. Khi đó, compiler sẽ quay ngược lại lên <code>parsePrecedence()</code>, dừng lại ở dấu <code>=</code> bất ngờ vẫn đang là token kế tiếp và báo lỗi.</p>
<p>Nếu chúng ta tìm thấy dấu <code>=</code> trong một ngữ cảnh <em>được</em> phép, thì sẽ compile biểu thức theo sau. Sau đó, ta sinh ra một instruction mới <span name="set"><code>OP_SET_PROPERTY</code></span>. Instruction này nhận một operand duy nhất là chỉ số của tên property trong constant table. Nếu không compile biểu thức set, ta mặc định đó là getter và sinh ra instruction <code>OP_GET_PROPERTY</code>, cũng nhận operand là tên property.</p>
<aside name="set">
<p>Bạn không thể <em>set</em> một property không phải field, nên instruction này lẽ ra có thể đặt tên là <code>OP_SET_FIELD</code>, nhưng tôi muốn giữ đồng nhất với instruction get cho đẹp.</p>
</aside>
<p>Giờ là lúc định nghĩa hai instruction mới này.</p>
<div class="codehilite"><pre class="insert-before">  OP_SET_UPVALUE,
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert">  <span class="a">OP_GET_PROPERTY</span>,
  <span class="a">OP_SET_PROPERTY</span>,
</pre><pre class="insert-after">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>Và thêm hỗ trợ giải mã (disassemble) chúng:</p>
<div class="codehilite"><pre class="insert-before">      return byteInstruction(&quot;OP_SET_UPVALUE&quot;, chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert">    <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_GET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">&quot;OP_SET_PROPERTY&quot;</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#execute-biểu-thức-getter-&-setter" id="execute-biểu-thức-getter-&-setter"><small>27&#8202;.&#8202;4&#8202;.&#8202;1</small>Execute biểu thức getter &amp; setter</a></h3>
<p>Chuyển sang runtime, ta sẽ bắt đầu với biểu thức get vì chúng đơn giản hơn một chút.</p>
<div class="codehilite"><pre class="insert-before">      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();

        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">pop</span>(); <span class="c">// Instance.</span>
          <span class="i">push</span>(<span class="i">value</span>);
          <span class="k">break</span>;
        }
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Khi interpreter gặp instruction này, biểu thức bên trái dấu chấm đã được execute và instance kết quả đang nằm trên đỉnh stack. Ta đọc tên field từ constant pool và tra cứu trong bảng field của instance. Nếu hash table chứa một entry với tên đó, ta pop instance và push giá trị của entry đó làm kết quả.</p>
<p>Tất nhiên, field có thể không tồn tại. Trong Lox, chúng ta định nghĩa đây là một runtime error. Vì vậy, ta thêm một bước kiểm tra và dừng nếu gặp trường hợp này.</p>
<div class="codehilite"><pre class="insert-before">          push(value);
          break;
        }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">

        <span class="i">runtimeError</span>(<span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
        <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
</pre><pre class="insert-after">      }
      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><span name="field">Có</span> một trường hợp lỗi khác cần xử lý mà có lẽ bạn đã nhận ra. Đoạn code trên giả định rằng biểu thức bên trái dấu chấm thực sự trả về một ObjInstance. Nhưng không có gì ngăn người dùng viết như sau:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">obj</span> = <span class="s">&quot;not an instance&quot;</span>;
<span class="k">print</span> <span class="i">obj</span>.<span class="i">field</span>;
</pre></div>
<p>Chương trình của người dùng là sai, nhưng VM vẫn phải xử lý một cách “êm đẹp”. Hiện tại, nó sẽ hiểu nhầm các bit của ObjString thành ObjInstance và… tôi cũng không biết, có thể “bốc cháy” hoặc làm gì đó chắc chắn không êm đẹp.</p>
<p>Trong Lox, chỉ instance mới được phép có field. Bạn không thể gắn field vào string hoặc number. Vì vậy, ta cần kiểm tra giá trị có phải là instance trước khi truy cập bất kỳ field nào của nó.</p>
<aside name="field">
<p>Lox <em>có thể</em> hỗ trợ thêm field vào các giá trị thuộc kiểu khác. Đây là ngôn ngữ của chúng ta và ta có thể làm điều mình muốn. Nhưng khả năng cao đây là một ý tưởng tồi. Nó làm phức tạp đáng kể phần cài đặt theo cách ảnh hưởng xấu đến hiệu năng — ví dụ, string interning sẽ khó hơn nhiều.</p>
<p>Ngoài ra, nó còn đặt ra những câu hỏi ngữ nghĩa rắc rối về equality và identity của giá trị. Nếu tôi gắn một field vào số <code>3</code>, thì kết quả của <code>1 + 2</code> có field đó không? Nếu có, implementation sẽ theo dõi điều đó thế nào? Nếu không, hai “số ba” kết quả đó có còn được coi là bằng nhau không?</p>
</aside>
<div class="codehilite"><pre class="insert-before">      case OP_GET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have properties.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(0));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Nếu giá trị trên stack không phải là instance, ta báo runtime error và thoát an toàn.</p>
<p>Tất nhiên, biểu thức get sẽ không hữu ích lắm nếu không instance nào có field. Để làm được điều đó, ta cần setter.</p>
<div class="codehilite"><pre class="insert-before">        return INTERPRET_RUNTIME_ERROR;
      }
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">      <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>));
        <span class="i">tableSet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="a">READ_STRING</span>(), <span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">Value</span> <span class="i">value</span> = <span class="i">pop</span>();
        <span class="i">pop</span>();
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Phần này phức tạp hơn một chút so với <code>OP_GET_PROPERTY</code>. Khi instruction này chạy, đỉnh stack là instance có field đang được gán, và ngay trên nó là giá trị cần lưu. Giống như trước, ta đọc operand của instruction và tìm string tên field. Dùng tên đó, ta lưu giá trị trên đỉnh stack vào bảng field của instance.</p>
<p>Sau đó là một chút “ảo thuật” với <span name="stack">stack</span>. Ta pop giá trị vừa lưu, rồi pop instance, và cuối cùng push lại giá trị đó. Nói cách khác, ta loại bỏ <em>phần tử thứ hai</em> từ đỉnh stack nhưng giữ nguyên phần tử trên cùng. Setter bản thân nó là một biểu thức mà kết quả là giá trị được gán, nên ta cần giữ giá trị đó lại trên stack. Ý tôi là như thế này:</p>
<aside name="stack">
<p>Các thao tác trên stack diễn ra như sau:</p><img src="image/classes-and-instances/stack.png" alt="Pop hai giá trị rồi push lại giá trị đầu tiên lên stack."/>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Toast</span> {}
<span class="k">var</span> <span class="i">toast</span> = <span class="t">Toast</span>();
<span class="k">print</span> <span class="i">toast</span>.<span class="i">jam</span> = <span class="s">&quot;grape&quot;</span>; <span class="c">// In ra &quot;grape&quot;.</span>
</pre></div>
<p>Khác với khi đọc một field, chúng ta không cần lo về việc hash table không chứa field đó. Một setter sẽ ngầm tạo field nếu cần. Tuy nhiên, ta vẫn cần xử lý trường hợp người dùng cố gắng lưu một field vào một giá trị không phải instance.</p>
<div class="codehilite"><pre class="insert-before">      case OP_SET_PROPERTY: {
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">runtimeError</span>(<span class="s">&quot;Only instances have fields.&quot;</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after">        ObjInstance* instance = AS_INSTANCE(peek(1));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Giống hệt như với biểu thức get, ta kiểm tra kiểu của giá trị và báo runtime error nếu nó không hợp lệ. Và như vậy, phần “có trạng thái” trong hỗ trợ lập trình hướng đối tượng của Lox đã hoàn thiện. Hãy thử nhé:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Pair</span> {}

<span class="k">var</span> <span class="i">pair</span> = <span class="t">Pair</span>();
<span class="i">pair</span>.<span class="i">first</span> = <span class="n">1</span>;
<span class="i">pair</span>.<span class="i">second</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">pair</span>.<span class="i">first</span> + <span class="i">pair</span>.<span class="i">second</span>; <span class="c">// 3.</span>
</pre></div>
<p>Điều này chưa thực sự mang cảm giác <em>hướng đối tượng</em>. Nó giống như một biến thể kỳ lạ, kiểu dynamic của C, nơi object chỉ là những “túi dữ liệu” lỏng lẻo giống struct. Kiểu như một ngôn ngữ thủ tục dynamic. Nhưng đây là một bước tiến lớn về khả năng biểu đạt. Bản cài đặt Lox của chúng ta giờ cho phép người dùng tự do gom dữ liệu thành các đơn vị lớn hơn. Trong chương tiếp theo, chúng ta sẽ “thổi hồn” vào những khối dữ liệu bất động đó.</p>
<div class="challenges">
<h2><a href="#thử-thách" id="thử-thách"><small>27&#8202;.&#8202;5</small>Thử thách</a></h2>
<ol>
<li>
<p>Việc cố truy cập một field không tồn tại trên object sẽ ngay lập tức dừng toàn bộ VM. Người dùng không có cách nào để phục hồi từ runtime error này, cũng như không có cách nào để kiểm tra xem một field có tồn tại <em>trước khi</em> cố truy cập nó. Người dùng phải tự đảm bảo rằng chỉ đọc các field hợp lệ.</p>
<p>Các ngôn ngữ dynamic khác xử lý field bị thiếu như thế nào? Bạn nghĩ Lox nên làm gì? Hãy cài đặt giải pháp của bạn.</p>
</li>
<li>
<p>Field được truy cập tại runtime bằng <em>tên chuỗi</em> của chúng. Nhưng tên đó luôn phải xuất hiện trực tiếp trong mã nguồn dưới dạng <em>identifier token</em>. Một chương trình không thể tạo ra một giá trị string một cách mệnh lệnh rồi dùng nó làm tên field. Bạn có nghĩ là nên cho phép không? Hãy nghĩ ra một tính năng ngôn ngữ cho phép điều đó và cài đặt nó.</p>
</li>
<li>
<p>Ngược lại, Lox không có cách nào để <em>xóa</em> một field khỏi instance. Bạn có thể gán giá trị <code>nil</code> cho field, nhưng entry trong hash table vẫn còn đó. Các ngôn ngữ khác xử lý việc này ra sao? Hãy chọn và cài đặt một chiến lược cho Lox.</p>
</li>
<li>
<p>Vì field được truy cập theo tên tại runtime, việc làm việc với trạng thái instance là chậm. Về mặt kỹ thuật, đây là một thao tác thời gian hằng số — nhờ hash table — nhưng hệ số hằng số lại khá lớn. Đây là một nguyên nhân chính khiến ngôn ngữ dynamic chậm hơn ngôn ngữ static.</p>
<p>Các bản cài đặt tinh vi của ngôn ngữ dynamic xử lý và tối ưu điều này như thế nào?</p>
</li>
</ol>
</div>

<footer>
<a href="methods-and-initializers.html" class="next">
  Đọc tiếp Chapter: &ldquo;Methods and Initializers&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
