<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Control Flow &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">Control Flow<small>9</small></a></h3>

<ul>
    <li><a href="#máy-turing-tóm-tắt"><small>9.1</small> Máy Turing (Tóm tắt)</a></li>
    <li><a href="#conditional-execution-execute-có-điều-kiện"><small>9.2</small> Conditional Execution (Execute có điều kiện)</a></li>
    <li><a href="#logical-operators"><small>9.3</small> Logical Operators</a></li>
    <li><a href="#while-loops"><small>9.4</small> While Loops</a></li>
    <li><a href="#for-loops"><small>9.5</small> For Loops</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Spoonfuls of Syntactic Sugar</a></li>
</ul>


<div class="prev-next">
    <a href="statements-and-state.html" title="Statements and State" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="functions.html" title="Functions" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="statements-and-state.html" title="Statements and State" class="prev">←</a>
<a href="functions.html" title="Functions" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">Control Flow<small>9</small></a></h3>

<ul>
    <li><a href="#máy-turing-tóm-tắt"><small>9.1</small> Máy Turing (Tóm tắt)</a></li>
    <li><a href="#conditional-execution-execute-có-điều-kiện"><small>9.2</small> Conditional Execution (Execute có điều kiện)</a></li>
    <li><a href="#logical-operators"><small>9.3</small> Logical Operators</a></li>
    <li><a href="#while-loops"><small>9.4</small> While Loops</a></li>
    <li><a href="#for-loops"><small>9.5</small> For Loops</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Spoonfuls of Syntactic Sugar</a></li>
</ul>


<div class="prev-next">
    <a href="statements-and-state.html" title="Statements and State" class="left">&larr;&nbsp;Chương trước</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="functions.html" title="Functions" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">9</div>
  <h1>Control Flow</h1>

<blockquote>
<p>Logic, giống như whiskey, sẽ mất tác dụng có lợi nếu dùng quá nhiều.</p>
<p><cite>Edward John Moreton Drax Plunkett, Lord Dunsany</cite></p>
</blockquote>
<p>So với <a href="statements-and-state.html">chương trước</a> — một cuộc chạy marathon đầy mệt mỏi — thì hôm nay giống như một buổi dạo chơi nhẹ nhàng giữa cánh đồng hoa cúc. Nhưng dù công việc khá dễ, phần thưởng lại bất ngờ lớn.</p>
<p>Hiện tại, interpreter của chúng ta chẳng khác gì một chiếc máy tính bỏ túi. Một chương trình Lox chỉ có thể thực hiện một lượng công việc cố định trước khi kết thúc. Muốn nó chạy lâu gấp đôi, bạn phải viết source code dài gấp đôi. Chúng ta sắp sửa thay đổi điều đó. Trong chương này, interpreter của chúng ta sẽ tiến một bước lớn để gia nhập “giải đấu lớn” của các ngôn ngữ lập trình: <em>Turing-completeness</em>.</p>
<h2><a href="#máy-turing-tóm-tắt" id="máy-turing-tóm-tắt"><small>9&#8202;.&#8202;1</small>Máy Turing (Tóm tắt)</a></h2>
<p>Vào đầu thế kỷ trước, các nhà toán học đã vấp phải một loạt <span name="paradox">nghịch lý</span> rối rắm khiến họ bắt đầu nghi ngờ sự vững chắc của nền tảng mà họ đã xây dựng. Để giải quyết <a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis">khủng hoảng</a> đó, họ quay lại điểm xuất phát. Bắt đầu từ một vài tiên đề, logic và lý thuyết tập hợp, họ hy vọng có thể xây dựng lại toán học trên một nền móng không thể bị phá vỡ.</p>
<aside name="paradox">
<p>Nổi tiếng nhất là <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox"><strong>nghịch lý Russell</strong></a>. Ban đầu, lý thuyết tập hợp cho phép bạn định nghĩa bất kỳ loại tập hợp nào. Nếu bạn có thể mô tả nó bằng tiếng Anh, thì nó hợp lệ. Tất nhiên, với sở thích tự tham chiếu của các nhà toán học, các tập hợp có thể chứa những tập hợp khác. Thế là Russell — tay “láu cá” ấy — đã nghĩ ra:</p>
<p><em>R là tập hợp của tất cả các tập hợp không chứa chính nó.</em></p>
<p>R có chứa chính nó không? Nếu không, thì theo nửa sau của định nghĩa, nó phải chứa chính nó. Nhưng nếu có, thì nó lại không còn thỏa định nghĩa nữa. Xin mời… nổ não.</p>
</aside>
<p>Họ muốn trả lời một cách chặt chẽ những câu hỏi như: “Liệu tất cả các mệnh đề đúng có thể được chứng minh không?”, “Chúng ta có thể <a href="https://en.wikipedia.org/wiki/Computable_function">tính toán</a> được tất cả các hàm mà ta có thể định nghĩa không?”, hay thậm chí là câu hỏi tổng quát hơn: “Chúng ta thực sự có ý gì khi nói một hàm là ‘computable’?”</p>
<p>Họ cho rằng câu trả lời cho hai câu hỏi đầu tiên sẽ là “có”. Việc còn lại chỉ là chứng minh nó. Nhưng hóa ra câu trả lời cho cả hai lại là “không”, và đáng ngạc nhiên là hai câu hỏi này lại gắn bó chặt chẽ với nhau. Đây là một góc thú vị của toán học, chạm đến những câu hỏi nền tảng về khả năng của bộ não và cách vũ trụ vận hành. Tôi không thể trình bày đầy đủ ở đây.</p>
<p>Điều tôi muốn nhấn mạnh là: trong quá trình chứng minh câu trả lời cho hai câu hỏi đầu tiên là “không”, Alan Turing và Alonzo Church đã đưa ra một câu trả lời chính xác cho câu hỏi cuối cùng — một định nghĩa về những loại hàm nào là <span name="uncomputable">computable</span>. Mỗi người đã tạo ra một hệ thống tí hon với lượng “máy móc” tối thiểu nhưng vẫn đủ mạnh để tính toán bất kỳ hàm nào trong một lớp (rất) lớn các hàm.</p>
<aside name="uncomputable">
<p>Họ chứng minh câu trả lời cho câu hỏi đầu tiên là “không” bằng cách chỉ ra rằng hàm trả về giá trị đúng/sai của một mệnh đề bất kỳ <em>không</em> phải là một hàm computable.</p>
</aside>
<p>Ngày nay, đây được xem là các “hàm computable”. Hệ thống của Turing được gọi là <span name="turing"><strong>máy Turing</strong></span>. Hệ thống của Church là <strong>lambda calculus</strong>. Cả hai vẫn được dùng rộng rãi làm nền tảng cho các mô hình tính toán, và thực tế là nhiều ngôn ngữ lập trình hàm hiện đại sử dụng lambda calculus làm lõi.</p>
<aside name="turing">
<p>Turing gọi phát minh của mình là “a-machine” (automatic machine). Ông không tự đề cao đến mức đặt tên mình vào đó. Sau này, các nhà toán học khác đã làm điều đó thay ông. Đó là cách bạn trở nên nổi tiếng mà vẫn giữ được chút khiêm tốn.</p>
</aside><img src="image/control-flow/turing-machine.png" alt="A Turing machine." />
<p>Máy Turing nổi tiếng hơn — chưa có bộ phim Hollywood nào về Alonzo Church — nhưng hai hệ thống này <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">tương đương về sức mạnh</a>. Thực tế, bất kỳ ngôn ngữ lập trình nào có mức độ biểu đạt tối thiểu cũng đủ mạnh để tính toán <em>bất kỳ</em> hàm computable nào.</p>
<p>Bạn có thể chứng minh điều đó bằng cách viết một trình mô phỏng máy Turing trong ngôn ngữ của mình. Vì Turing đã chứng minh máy của ông có thể tính toán bất kỳ hàm computable nào, nên theo đó, ngôn ngữ của bạn cũng có thể. Tất cả những gì bạn cần làm là dịch hàm đó sang máy Turing, rồi chạy nó trên trình mô phỏng của bạn.</p>
<p>Nếu ngôn ngữ của bạn đủ biểu đạt để làm điều đó, nó được xem là <strong>Turing-complete</strong>. Máy Turing thực ra khá đơn giản, nên không cần nhiều sức mạnh để đạt được điều này. Bạn chỉ cần có phép toán số học, một chút control flow, và khả năng cấp phát và sử dụng (về lý thuyết) lượng bộ nhớ tùy ý. Chúng ta đã có điều đầu tiên. Đến cuối chương này, chúng ta sẽ có <span name="memory">điều thứ hai</span>.</p>
<aside name="memory">
<p>Chúng ta <em>gần như</em> đã có điều thứ ba. Bạn có thể tạo và nối chuỗi với kích thước tùy ý, nên bạn <em>có thể</em> lưu trữ bộ nhớ không giới hạn. Nhưng chúng ta chưa có cách nào để truy cập một phần của chuỗi.</p>
</aside>
<h2><a href="#conditional-execution-execute-có-điều-kiện" id="conditional-execution-execute-có-điều-kiện"><small>9&#8202;.&#8202;2</small>Conditional Execution (Execute có điều kiện)</a></h2>
<p>Đủ với phần lịch sử rồi, giờ hãy làm cho ngôn ngữ của chúng ta thú vị hơn. Ta có thể chia control flow thành hai loại chính:</p>
<ul>
<li>
<p><strong>Conditional</strong> hay <strong>branching control flow</strong> được dùng để <em>không</em> execute một đoạn code nào đó. Theo cách nhìn của lập trình mệnh lệnh, bạn có thể hình dung nó như việc “nhảy <em>vượt qua</em>” một vùng code.</p>
</li>
<li>
<p><strong>Looping control flow</strong> execute một đoạn code nhiều hơn một lần. Nó “nhảy <em>lùi lại</em>” để bạn có thể làm lại điều gì đó. Vì bạn thường không muốn vòng lặp <em>vô hạn</em>, nó thường đi kèm một logic điều kiện để biết khi nào cần dừng.</p>
</li>
</ul>
<p>Branching đơn giản hơn, nên ta sẽ bắt đầu từ đây. Các ngôn ngữ họ C có hai tính năng chính để execute có điều kiện: câu lệnh <code>if</code> và toán tử “conditional” <span name="ternary">được đặt tên rất rõ nghĩa</span> (<code>?:</code>). Câu lệnh <code>if</code> cho phép bạn execute có điều kiện các statement, còn toán tử conditional cho phép bạn execute có điều kiện các expression.</p>
<aside name="ternary">
<p>Toán tử conditional còn được gọi là toán tử “ternary” vì nó là toán tử duy nhất trong C nhận ba toán hạng.</p>
</aside>
<p>Để đơn giản, Lox không có toán tử conditional, nên hãy bắt đầu với câu lệnh <code>if</code>. Grammar cho statement của chúng ta sẽ có thêm một production mới.</p>
<p><span name="semicolon"></span></p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">ifStmt</span>         → <span class="s">&quot;if&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span>
               ( <span class="s">&quot;else&quot;</span> <span class="i">statement</span> )? ;
</pre></div>
<aside name="semicolon">
<p>Dấu chấm phẩy trong các rule không được đặt trong dấu nháy, nghĩa là chúng là một phần của metasyntax của grammar, không phải syntax của Lox. Một block không có <code>;</code> ở cuối và một câu lệnh <code>if</code> cũng vậy, trừ khi then hoặc else statement tình flag là một statement kết thúc bằng dấu chấm phẩy.</p>
</aside>
<p>Một câu lệnh <code>if</code> có một expression làm điều kiện, sau đó là một statement sẽ được execute nếu điều kiện là truthy. Tùy chọn, nó cũng có thể có từ khóa <code>else</code> và một statement sẽ được execute nếu điều kiện là falsey. <span name="if-ast">Node của syntax tree</span> sẽ có các field cho cả ba phần này.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Expression : Expr expression&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;If         : Expr condition, Stmt thenBranch,&quot;</span> +
                  <span class="s">&quot; Stmt elseBranch&quot;</span>,
</pre><pre class="insert-after">      &quot;Print      : Expr expression&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="if-ast">
<p>Code được generated cho node mới này nằm trong <a href="appendix-ii.html#if-statement">Appendix II</a>.</p>
</aside>
<p>Giống như các statement khác, parser nhận biết một câu lệnh <code>if</code> bằng từ khóa <code>if</code> ở đầu.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IF</span>)) <span class="k">return</span> <span class="i">ifStatement</span>();
</pre><pre class="insert-after">    if (match(PRINT)) return printStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Khi gặp nó, parser sẽ gọi method mới này để parse phần còn lại:</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">ifStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;if&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after if condition.&quot;</span>);<span name="parens"> </span>

    <span class="t">Stmt</span> <span class="i">thenBranch</span> = <span class="i">statement</span>();
    <span class="t">Stmt</span> <span class="i">elseBranch</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">ELSE</span>)) {
      <span class="i">elseBranch</span> = <span class="i">statement</span>();
    }

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">If</span>(<span class="i">condition</span>, <span class="i">thenBranch</span>, <span class="i">elseBranch</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<aside name="parens">
<p>Dấu ngoặc đơn quanh điều kiện chỉ hữu ích một nửa. Bạn cần một loại ký hiệu phân tách <em>giữa</em> điều kiện và then statement, nếu không parser sẽ không biết khi nào điều kiện kết thúc. Nhưng dấu ngoặc <em>mở</em> ngay sau <code>if</code> thì không thực sự hữu ích. Dennis Ritchie đặt nó ở đó để ông có thể dùng <code>)</code> làm ký hiệu kết thúc mà không bị mất cân bằng ngoặc.</p>
<p>Các ngôn ngữ khác như Lua và một số BASIC dùng từ khóa như <code>then</code> làm ký hiệu kết thúc và không có gì trước điều kiện. Go và Swift thì yêu cầu statement phải là một block có ngoặc nhọn. Điều đó cho phép chúng dùng <code>{</code> ở đầu statement để xác định khi nào điều kiện kết thúc.</p>
</aside>
<p>Như thường lệ, code parse bám sát grammar. Nó phát hiện một else clause bằng cách tìm từ khóa <code>else</code> ngay trước đó. Nếu không có, field <code>elseBranch</code> trong syntax tree sẽ là <code>null</code>.</p>
<p>Tùy chọn else tưởng chừng vô hại này thực ra đã mở ra một điểm mơ hồ trong grammar. Hãy xem ví dụ:</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">first</span>) <span class="k">if</span> (<span class="i">second</span>) <span class="i">whenTrue</span>(); <span class="k">else</span> <span class="i">whenFalse</span>();
</pre></div>
<p>Câu đố là: else clause đó thuộc về câu lệnh <code>if</code> nào? Đây không chỉ là câu hỏi lý thuyết về cách ta ghi grammar, mà nó thực sự ảnh hưởng đến cách code chạy:</p>
<ul>
<li>
<p>Nếu ta gắn else vào câu lệnh <code>if</code> đầu tiên, thì <code>whenFalse()</code> sẽ được gọi nếu <code>first</code> là falsey, bất kể <code>second</code> có giá trị gì.</p>
</li>
<li>
<p>Nếu ta gắn nó vào câu lệnh <code>if</code> thứ hai, thì <code>whenFalse()</code> chỉ được gọi nếu <code>first</code> là truthy và <code>second</code> là falsey.</p>
</li>
</ul>
<p>Vì else clause là tùy chọn, và không có ký hiệu phân tách rõ ràng đánh dấu kết thúc câu lệnh <code>if</code>, grammar sẽ trở nên mơ hồ khi bạn lồng các <code>if</code> theo cách này. Đây là một cạm bẫy kinh điển của cú pháp, được gọi là vấn đề <strong><a href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a></strong>.</p>
<p><span name="else"></span></p><img class="above" src="image/control-flow/dangling-else.png" alt="Hai cách mà else có thể được diễn giải." />
<aside name="else">
<p>Ở đây, cách format làm nổi bật hai cách mà else có thể được parse. Nhưng lưu ý rằng vì parser bỏ qua các ký tự whitespace, đây chỉ là gợi ý cho người đọc.</p>
</aside>
<p>Hoàn toàn <em>có thể</em> định nghĩa một context-free grammar để tránh sự mơ hồ này một cách trực tiếp, nhưng điều đó đòi hỏi phải tách hầu hết các rule cho statement thành từng cặp: một loại cho phép <code>if</code> có <code>else</code> và một loại không. Khá là phiền phức.</p>
<p>Thay vào đó, hầu hết các ngôn ngữ và parser đều tránh vấn đề này theo cách ad hoc. Dù họ dùng “mẹo” gì để thoát khỏi rắc rối, họ luôn chọn cùng một cách diễn giải — <code>else</code> sẽ gắn với câu lệnh <code>if</code> gần nhất đứng trước nó.</p>
<p>Parser của chúng ta thật tiện lợi khi đã làm đúng như vậy. Vì <code>ifStatement()</code> luôn chủ động tìm <code>else</code> trước khi trả về, nên lời gọi sâu nhất trong chuỗi <code>if</code> lồng nhau sẽ “giành” else clause cho mình trước khi trả quyền điều khiển về các câu lệnh <code>if</code> bên ngoài.</p>
<p>Giờ đã có cú pháp trong tay, chúng ta sẵn sàng để interpret.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitExpressionStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>

<p>Phần implement trong interpreter chỉ là một lớp bọc mỏng quanh chính đoạn code Java tương ứng. Nó sẽ evaluate điều kiện. Nếu điều kiện là truthy, nó execute then branch. Ngược lại, nếu có else branch, nó sẽ execute phần đó.</p>
<p>Nếu bạn so sánh đoạn code này với cách interpreter xử lý các cú pháp khác mà ta đã implement, điểm khiến control flow trở nên đặc biệt chính là câu lệnh <code>if</code> của Java. Hầu hết các syntax tree khác luôn evaluate toàn bộ subtree của chúng. Ở đây, ta có thể <em>không</em> evaluate then hoặc else statement. Nếu một trong hai có side effect, việc không evaluate nó sẽ trở nên “thấy được” đối với người dùng.</p>
<h2><a href="#logical-operators" id="logical-operators"><small>9&#8202;.&#8202;3</small>Logical Operators</a></h2>
<p>Vì chúng ta không có toán tử conditional, bạn có thể nghĩ rằng phần branching đã xong, nhưng chưa đâu. Ngay cả khi không có toán tử ternary, vẫn còn hai toán tử khác về mặt kỹ thuật cũng là control flow construct — đó là các logical operator <code>and</code> và <code>or</code>.</p>
<p>Chúng không giống các binary operator khác vì chúng <strong>short-circuit</strong>. Nếu sau khi evaluate toán hạng bên trái mà ta đã biết kết quả của biểu thức logic sẽ là gì, thì ta sẽ không evaluate toán hạng bên phải nữa. Ví dụ:</p>
<div class="codehilite"><pre><span class="k">false</span> <span class="k">and</span> <span class="i">sideEffect</span>();
</pre></div>
<p>Với một biểu thức <code>and</code> để ra kết quả truthy, cả hai toán hạng phải truthy. Ngay khi evaluate toán hạng bên trái là <code>false</code>, ta biết điều kiện đó không thể xảy ra, nên không cần evaluate <code>sideEffect()</code> và nó sẽ bị bỏ qua.</p>
<p>Đây là lý do tại sao ta không implement logical operator cùng với các binary operator khác. Giờ thì ta đã sẵn sàng. Hai toán tử mới này nằm khá thấp trong bảng precedence. Tương tự như <code>||</code> và <code>&amp;&amp;</code> trong C, mỗi toán tử có <span name="logical">precedence riêng</span>, với <code>or</code> thấp hơn <code>and</code>. Ta sẽ đặt chúng ngay giữa <code>assignment</code> và <code>equality</code>.</p>
<aside name="logical">
<p>Tôi luôn tự hỏi tại sao chúng không có cùng precedence, giống như các toán tử so sánh hoặc equality khác.</p>
</aside>
<div class="codehilite"><pre><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
<span class="i">logic_or</span>       → <span class="i">logic_and</span> ( <span class="s">&quot;or&quot;</span> <span class="i">logic_and</span> )* ;
<span class="i">logic_and</span>      → <span class="i">equality</span> ( <span class="s">&quot;and&quot;</span> <span class="i">equality</span> )* ;
</pre></div>
<p>Thay vì quay về <code>equality</code>, giờ <code>assignment</code> sẽ chuyển tiếp sang <code>logic_or</code>. Hai rule mới, <code>logic_or</code> và <code>logic_and</code>, <span name="same">tương tự</span> như các binary operator khác. Sau đó, <code>logic_and</code> sẽ gọi <code>equality</code> cho các toán hạng của nó, và từ đó ta nối lại với phần còn lại của các rule expression.</p>
<aside name="same">
<p><em>Syntax</em> không quan tâm đến việc chúng short-circuit. Đó là vấn đề thuộc về semantics.</p>
</aside>
<p>Chúng ta <em>có thể</em> tái sử dụng class <code>Expr.Binary</code> hiện có cho hai expression mới này vì chúng có cùng các field. Nhưng khi đó, <code>visitBinaryExpr()</code> sẽ phải kiểm tra xem operator có phải là logical operator không và dùng một nhánh code khác để xử lý short-circuit. Tôi nghĩ sẽ gọn gàng hơn nếu định nghĩa một <span name="logical-ast">class mới</span> cho các toán tử này để chúng có visit method riêng.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Literal  : Object value&quot;,
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert">      <span class="s">&quot;Logical  : Expr left, Token operator, Expr right&quot;</span>,
</pre><pre class="insert-after">      &quot;Unary    : Token operator, Expr right&quot;,
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>

<aside name="logical-ast">
<p>Code được generated cho node mới này nằm trong <a href="appendix-ii.html#logical-expression">Appendix II</a>.</p>
</aside>
<p>Để đưa các expression mới này vào parser, trước tiên ta thay đổi code parse cho assignment để gọi <code>or()</code>.</p>
<div class="codehilite"><pre class="insert-before">  private Expr assignment() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>assignment</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">or</span>();
</pre><pre class="insert-after">

    if (match(EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>(), replace 1 line</div>

<p>Code để parse một chuỗi các biểu thức <code>or</code> giống với các binary operator khác.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>assignment</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">or</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">and</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">OR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">and</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>assignment</em>()</div>

<p>Các toán hạng của nó sẽ là cấp precedence cao hơn tiếp theo — biểu thức <code>and</code> mới.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>or</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Expr</span> <span class="i">and</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">AND</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">equality</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>or</em>()</div>

<p>Biểu thức này sẽ gọi <code>equality()</code> cho các toán hạng của nó, và như vậy, parser cho expression đã được nối kết đầy đủ trở lại. Giờ ta sẵn sàng để interpret.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);

    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">OR</span>) {
      <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    } <span class="k">else</span> {
      <span class="k">if</span> (!<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    }

    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>

<p>Nếu bạn so sánh đoạn này với method <code>visitBinaryExpr()</code> trong <a href="evaluating-expressions.html">chương trước</a>, bạn sẽ thấy sự khác biệt. Ở đây, chúng ta evaluate toán hạng bên trái trước. Ta xem giá trị của nó để quyết định có thể short-circuit hay không. Nếu không, <em>và chỉ khi đó</em>, ta mới evaluate toán hạng bên phải.</p>
<p>Điểm thú vị khác ở đây là quyết định giá trị thực sự sẽ trả về. Vì Lox là ngôn ngữ dynamically typed, chúng ta cho phép toán hạng thuộc bất kỳ kiểu nào và dùng truthiness để xác định ý nghĩa của mỗi toán hạng. Ta áp dụng cùng cách suy luận đó cho kết quả. Thay vì hứa sẽ trả về đúng <code>true</code> hoặc <code>false</code>, một logic operator chỉ đảm bảo rằng nó sẽ trả về một giá trị có truthiness phù hợp.</p>
<p>May mắn thay, chúng ta đã có sẵn các giá trị với truthiness đúng — chính là kết quả của các toán hạng. Vậy nên ta dùng luôn chúng. Ví dụ:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;hi&quot;</span> <span class="k">or</span> <span class="n">2</span>; <span class="c">// &quot;hi&quot;.</span>
<span class="k">print</span> <span class="k">nil</span> <span class="k">or</span> <span class="s">&quot;yes&quot;</span>; <span class="c">// &quot;yes&quot;.</span>
</pre></div>
<p>Ở dòng đầu tiên, <code>"hi"</code> là truthy, nên <code>or</code> short-circuit và trả về giá trị đó. Ở dòng thứ hai, <code>nil</code> là falsey, nên nó evaluate và trả về toán hạng thứ hai, <code>"yes"</code>.</p>
<p>Vậy là chúng ta đã bao quát hết các primitive branching trong Lox. Giờ thì sẵn sàng “nhảy” sang vòng lặp. Thấy tôi chơi chữ chứ? <em>Jump. Ahead.</em> Hiểu không? Ý là… thôi, bỏ qua đi.</p>
<h2><a href="#while-loops" id="while-loops"><small>9&#8202;.&#8202;4</small>While Loops</a></h2>
<p>Lox có hai câu lệnh looping control flow: <code>while</code> và <code>for</code>. Vòng lặp <code>while</code> đơn giản hơn, nên ta sẽ bắt đầu từ đây. Grammar của nó giống hệt C.</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">whileStmt</span>      → <span class="s">&quot;while&quot;</span> <span class="s">&quot;(&quot;</span> <span class="i">expression</span> <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<p>Ta thêm một nhánh mới vào rule <code>statement</code> trỏ đến rule mới cho <code>while</code>. Nó bắt đầu bằng từ khóa <code>while</code>, theo sau là một biểu thức điều kiện đặt trong ngoặc đơn, rồi đến một statement cho phần thân vòng lặp. Rule grammar mới này sẽ có một <span name="while-ast">node trong syntax tree</span>.</p>
<div class="codehilite"><pre class="insert-before">      &quot;Print      : Expr expression&quot;,
</pre><pre class="insert-before">      <span class="s">&quot;Var        : Token name, Expr initializer&quot;</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()<br>
add <em>&ldquo;,&rdquo;</em> to previous line</div>
<pre class="insert">      <span class="s">&quot;While      : Expr condition, Stmt body&quot;</span>
</pre><pre class="insert-after">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>&ldquo;,&rdquo;</em> to previous line</div>

<aside name="while-ast">
<p>Code được generated cho node mới này nằm trong <a href="appendix-ii.html#while-statement">Appendix II</a>.</p>
</aside>
<p>Node này lưu trữ điều kiện và phần thân. Ở đây bạn có thể thấy lý do tại sao việc tách riêng base class cho expression và statement lại hữu ích. Các khai báo field cho thấy rõ ràng điều kiện là một expression và phần thân là một statement.</p>
<p>Bên phía parser, ta làm theo đúng quy trình đã dùng cho câu lệnh <code>if</code>. Đầu tiên, ta thêm một case mới trong <code>statement()</code> để phát hiện và khớp từ khóa ở đầu.</p>
<div class="codehilite"><pre class="insert-before">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">WHILE</span>)) <span class="k">return</span> <span class="i">whileStatement</span>();
</pre><pre class="insert-after">    if (match(LEFT_BRACE)) return new Stmt.Block(block());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Việc xử lý thực sự được giao cho method này:</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>varDeclaration</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">whileStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;while&#39;.&quot;</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after condition.&quot;</span>);
    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>varDeclaration</em>()</div>

<p>Grammar này cực kỳ đơn giản và đây là bản dịch thẳng của nó sang Java. Nói đến dịch thẳng sang Java, đây là cách ta execute cú pháp mới:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre>  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="k">while</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>

<p>Giống như visit method cho <code>if</code>, visitor này dùng chính tính năng tương ứng của Java. Method này không phức tạp, nhưng nó khiến Lox mạnh mẽ hơn nhiều. Giờ ta có thể viết một chương trình mà thời gian chạy không còn bị giới hạn nghiêm ngặt bởi độ dài của source code.</p>
<h2><a href="#for-loops" id="for-loops"><small>9&#8202;.&#8202;5</small>For Loops</a></h2>
<p>Chúng ta đã đến control flow construct cuối cùng, <span name="for">Ye Olde</span> vòng lặp <code>for</code> kiểu C. Có lẽ tôi không cần nhắc bạn, nhưng nó trông như thế này:</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">10</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) <span class="k">print</span> <span class="i">i</span>;
</pre></div>
<p>Theo ngôn ngữ grammar, nó là:</p>
<div class="codehilite"><pre><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">forStmt</span>        → <span class="s">&quot;for&quot;</span> <span class="s">&quot;(&quot;</span> ( <span class="i">varDecl</span> | <span class="i">exprStmt</span> | <span class="s">&quot;;&quot;</span> )
                 <span class="i">expression</span>? <span class="s">&quot;;&quot;</span>
                 <span class="i">expression</span>? <span class="s">&quot;)&quot;</span> <span class="i">statement</span> ;
</pre></div>
<aside name="for">
<p>Hầu hết các ngôn ngữ hiện đại đều có câu lệnh vòng lặp cấp cao hơn để duyệt qua các sequence do người dùng định nghĩa. C# có <code>foreach</code>, Java có “enhanced for”, thậm chí C++ giờ cũng có <code>for</code> dựa trên range. Chúng mang lại cú pháp gọn gàng hơn so với <code>for</code> của C bằng cách ngầm gọi vào một iteration protocol mà đối tượng được lặp hỗ trợ.</p>
<p>Tôi rất thích những thứ đó. Nhưng với Lox, chúng ta bị giới hạn bởi việc xây dựng interpreter từng chương một. Chúng ta chưa có object và method, nên chưa thể định nghĩa một iteration protocol mà vòng lặp <code>for</code> có thể dùng. Vậy nên ta sẽ gắn bó với vòng lặp <code>for</code> kiểu C cổ điển. Hãy coi nó như một món “vintage” — chiếc fixie của các câu lệnh control flow.</p>
</aside>
<p>Bên trong dấu ngoặc đơn, bạn có ba mệnh đề được phân tách bằng dấu chấm phẩy:</p>
<ol>
<li>
<p>Mệnh đề đầu tiên là <em>initializer</em>. Nó được execute đúng một lần, trước mọi thứ khác. Thông thường nó là một expression, nhưng để tiện lợi, chúng ta cũng cho phép một khai báo biến. Trong trường hợp đó, biến sẽ có scope trong phần còn lại của vòng lặp <code>for</code> — tức hai mệnh đề còn lại và phần thân.</p>
</li>
<li>
<p>Tiếp theo là <em>condition</em>. Giống như trong vòng lặp <code>while</code>, expression này kiểm soát thời điểm thoát vòng lặp. Nó được evaluate một lần ở đầu mỗi lượt lặp, bao gồm cả lượt đầu tiên. Nếu kết quả là truthy, nó execute phần thân vòng lặp. Ngược lại, nó sẽ thoát.</p>
</li>
<li>
<p>Mệnh đề cuối cùng là <em>increment</em>. Đây là một expression tùy ý làm một việc nào đó ở cuối mỗi lượt lặp. Kết quả của expression sẽ bị bỏ đi, vì thế để có ích thì nó phải có side effect. Trên thực tế, nó thường tăng giá trị của một biến.</p>
</li>
</ol>
<p>Bất kỳ mệnh đề nào trong số này cũng có thể được lược bỏ. Sau dấu ngoặc đơn đóng là một statement cho phần thân, thường là một block.</p>
<h3><a href="#desugaring" id="desugaring"><small>9&#8202;.&#8202;5&#8202;.&#8202;1</small>Desugaring</a></h3>
<p>Khá nhiều “máy móc”, nhưng lưu ý rằng không có phần nào làm những việc mà bạn không thể làm với các câu lệnh chúng ta đã có. Nếu vòng lặp <code>for</code> không hỗ trợ mệnh đề initializer, bạn có thể đặt expression initializer trước câu lệnh <code>for</code>. Không có mệnh đề increment, bạn chỉ việc đặt expression increment ở cuối phần thân.</p>
<p>Nói cách khác, Lox không <em>cần</em> vòng lặp <code>for</code>, chỉ là nó khiến một số mẫu code thường gặp trở nên dễ viết hơn. Những tính năng kiểu này được gọi là <span name="sugar"><strong>syntactic sugar</strong></span>. Ví dụ, vòng lặp <code>for</code> trước đó có thể được viết lại như sau:</p>
<aside name="sugar">
<p>Cụm từ duyên dáng này do Peter J. Landin đặt ra năm 1964 để mô tả cách một số dạng biểu thức đẹp đẽ được các ngôn ngữ như ALGOL hỗ trợ thực chất là lớp “đường” rắc lên trên phần nền tảng — nhưng có lẽ kém ngon miệng hơn — là lambda calculus bên dưới.</p><img class="above" src="image/control-flow/sugar.png" alt="Slightly more than a spoonful of sugar." />
</aside>
<div class="codehilite"><pre>{
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">while</span> (<span class="i">i</span> &lt; <span class="n">10</span>) {
    <span class="k">print</span> <span class="i">i</span>;
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
  }
}
</pre></div>
<p>Script này có semantics giống hệt với script trước đó, dù nhìn không “mát mắt” bằng. Những tính năng syntactic sugar như vòng lặp <code>for</code> của Lox khiến ngôn ngữ dễ chịu và hiệu quả hơn khi làm việc. Nhưng đặc biệt trong các implementation ngôn ngữ tinh vi, mỗi tính năng cần hỗ trợ và tối ưu ở back-end đều tốn kém.</p>
<p>Chúng ta có thể “vừa ăn bánh vừa giữ bánh” bằng cách <span
name="caramel"><strong>desugaring</strong></span>. Từ ngữ vui tai này mô tả quá trình trong đó front end nhận code dùng cú pháp sugar và dịch nó sang một dạng nguyên thủy hơn mà back end đã biết cách execute.</p>
<aside name="caramel">
<p>Ôi, tôi ước gì thuật ngữ được chấp nhận là “caramelization”. Đã đưa ra ẩn dụ thì sao lại không đi đến cùng nhỉ?</p>
</aside>
<p>Chúng ta sẽ desugar vòng lặp <code>for</code> thành vòng lặp <code>while</code> và các câu lệnh khác mà interpreter đã xử lý được. Trong interpreter đơn giản của chúng ta, desugaring thật ra không tiết kiệm được bao nhiêu công, nhưng nó cho tôi cái cớ để giới thiệu bạn với kỹ thuật này. Vì vậy, khác với các câu lệnh trước, chúng ta <em>sẽ không</em> thêm một node mới vào syntax tree. Thay vào đó, ta đi thẳng vào parsing. Đầu tiên, thêm một import mà ta sắp cần.</p>
<div class="codehilite"><pre class="insert-before">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert"><span class="k">import</span> <span class="i">java.util.Arrays</span>;
</pre><pre class="insert-after">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>

<p>Giống như mọi câu lệnh khác, ta bắt đầu parse một vòng lặp <code>for</code> bằng cách khớp từ khóa của nó.</p>
<div class="codehilite"><pre class="insert-before">  private Stmt statement() {
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>statement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FOR</span>)) <span class="k">return</span> <span class="i">forStatement</span>();
</pre><pre class="insert-after">    if (match(IF)) return ifStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>

<p>Giờ thì thú vị đây. Việc desugaring sẽ diễn ra ở đây, nên ta sẽ xây dựng method này từng phần, bắt đầu bằng dấu ngoặc mở trước các mệnh đề.</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>statement</em>()</div>
<pre>  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">forStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">&quot;Expect &#39;(&#39; after &#39;for&#39;.&quot;</span>);

    <span class="c">// More here...</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>

<p>Mệnh đề đầu tiên sau đó là initializer.</p>
<div class="codehilite"><pre class="insert-before">    consume(LEFT_PAREN, &quot;Expect '(' after 'for'.&quot;);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()<br>
replace 1 line</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">initializer</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">initializer</span> = <span class="k">null</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) {
      <span class="i">initializer</span> = <span class="i">varDeclaration</span>();
    } <span class="k">else</span> {
      <span class="i">initializer</span> = <span class="i">expressionStatement</span>();
    }
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>(), replace 1 line</div>

<p>Nếu token ngay sau <code>(</code> là dấu chấm phẩy thì initializer đã bị lược bỏ. Ngược lại, ta kiểm tra từ khóa <code>var</code> để xem đó có phải là một khai báo <span
name="variable">variable</span> hay không. Nếu không rơi vào trường hợp nào, chắc chắn đó là một expression. Ta parse nó và bọc nó trong một expression statement để initializer luôn có kiểu Stmt.</p>
<aside name="variable">
<p>Ở một chương trước, tôi đã nói rằng ta có thể tách syntax tree cho expression và statement thành hai hệ phân cấp class riêng biệt vì không có một vị trí nào trong grammar cho phép cả expression lẫn statement. Có lẽ điều đó không <em>hoàn toàn</em> đúng, nhỉ.</p>
</aside>
<p>Tiếp theo là phần điều kiện.</p>
<div class="codehilite"><pre class="insert-before">      initializer = expressionStatement();
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">condition</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">condition</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">&quot;Expect &#39;;&#39; after loop condition.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Một lần nữa, ta kiểm tra dấu chấm phẩy để xem mệnh đề này có bị lược bỏ hay không. Mệnh đề cuối cùng là phần increment.</p>
<div class="codehilite"><pre class="insert-before">    consume(SEMICOLON, &quot;Expect ';' after loop condition.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">

    <span class="t">Expr</span> <span class="i">increment</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="i">increment</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">&quot;Expect &#39;)&#39; after for clauses.&quot;</span>);
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Nó giống với mệnh đề điều kiện, chỉ khác là mệnh đề này kết thúc bằng dấu ngoặc đơn đóng. Phần còn lại chỉ là <span name="body">body</span>.</p>
<aside name="body">
<p>Chỉ mình tôi thấy hay nó nghe hơi… rùng rợn? “Tất cả những gì còn lại… là <em>cái xác</em>”.</p>
</aside>
<div class="codehilite"><pre class="insert-before">    consume(RIGHT_PAREN, &quot;Expect ')' after for clauses.&quot;);
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="i">body</span>;
</pre><pre class="insert-after">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Chúng ta đã parse xong tất cả các phần của vòng lặp <code>for</code> và các AST node kết quả đang nằm trong một vài biến local của Java. Đây là lúc desugaring xuất hiện. Ta lấy chúng và dùng để tạo ra các node của syntax tree thể hiện semantics của vòng lặp <code>for</code>, giống như ví dụ “tự desugar bằng tay” mà tôi đã cho bạn xem trước đó.</p>
<p>Code sẽ đơn giản hơn một chút nếu ta làm ngược lại, nên ta bắt đầu với mệnh đề increment.</p>
<div class="codehilite"><pre class="insert-before">    Stmt body = statement();

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">increment</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(
          <span class="t">Arrays</span>.<span class="i">asList</span>(
              <span class="i">body</span>,
              <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">increment</span>)));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Phần increment, nếu có, sẽ chạy sau body ở mỗi vòng lặp. Ta làm điều đó bằng cách thay thế body bằng một block nhỏ chứa body gốc, sau đó là một expression statement để evaluate phần increment.</p>
<div class="codehilite"><pre class="insert-before">    }

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">condition</span> == <span class="k">null</span>) <span class="i">condition</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Tiếp theo, ta lấy điều kiện và body để tạo vòng lặp bằng <code>while</code> loop nguyên thủy. Nếu điều kiện bị lược bỏ, ta chèn <code>true</code> để tạo vòng lặp vô hạn.</p>
<div class="codehilite"><pre class="insert-before">    body = new Stmt.While(condition, body);

</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>forStatement</em>()</div>
<pre class="insert">    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="t">Arrays</span>.<span class="i">asList</span>(<span class="i">initializer</span>, <span class="i">body</span>));
    }

</pre><pre class="insert-after">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>

<p>Cuối cùng, nếu có initializer, nó sẽ chạy một lần trước toàn bộ vòng lặp. Ta làm điều đó bằng cách, một lần nữa, thay thế toàn bộ statement bằng một block chạy initializer rồi execute vòng lặp.</p>
<p>Vậy là xong. Interpreter của chúng ta giờ đã hỗ trợ vòng lặp <code>for</code> kiểu C mà không cần đụng gì đến class Interpreter. Vì ta đã desugar thành các node mà interpreter vốn đã biết cách visit, nên không còn việc gì phải làm thêm.</p>
<p>Cuối cùng, Lox đã đủ mạnh để giải trí cho chúng ta, ít nhất là vài phút. Đây là một chương trình nhỏ in ra 21 phần tử đầu tiên của dãy Fibonacci:</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">0</span>;
<span class="k">var</span> <span class="i">temp</span>;

<span class="k">for</span> (<span class="k">var</span> <span class="i">b</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10000</span>; <span class="i">b</span> = <span class="i">temp</span> + <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">temp</span> = <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">b</span>;
}
</pre></div>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Vài chương nữa, khi Lox hỗ trợ first-class function và dynamic dispatch, về mặt kỹ thuật chúng ta sẽ không <em>cần</em> các câu lệnh branching được tích hợp sẵn trong ngôn ngữ. Hãy chỉ ra cách execute có điều kiện có thể được triển khai dựa trên những tính năng đó. Nêu tên một ngôn ngữ sử dụng kỹ thuật này cho control flow của nó.</p>
</li>
<li>
<p>Tương tự, looping cũng có thể được triển khai bằng những công cụ đó, miễn là interpreter của chúng ta hỗ trợ một tối ưu hóa quan trọng. Đó là gì, và tại sao nó lại cần thiết? Nêu tên một ngôn ngữ sử dụng kỹ thuật này cho iteration.</p>
</li>
<li>
<p>Không giống Lox, hầu hết các ngôn ngữ kiểu C khác cũng hỗ trợ câu lệnh <code>break</code> và <code>continue</code> bên trong vòng lặp. Hãy thêm hỗ trợ cho câu lệnh <code>break</code>.</p>
<p>Cú pháp là từ khóa <code>break</code> theo sau bởi dấu chấm phẩy. Sẽ là lỗi cú pháp nếu có câu lệnh <code>break</code> xuất hiện bên ngoài bất kỳ vòng lặp bao quanh nào. Khi runtime gặp câu lệnh <code>break</code>, nó sẽ nhảy đến cuối vòng lặp bao quanh gần nhất và tiếp tục từ đó. Lưu ý rằng <code>break</code> có thể nằm lồng bên trong các block hoặc câu lệnh <code>if</code> khác cũng cần được thoát ra.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Spoonfuls of Syntactic Sugar</a></h2>
<p>Khi bạn thiết kế ngôn ngữ của riêng mình, bạn sẽ chọn lượng syntactic sugar để “rót” vào grammar. Bạn sẽ tạo ra một món ăn “healthy” không đường, nơi mỗi thao tác semantics ánh xạ 1-1 với một đơn vị cú pháp, hay một món tráng miệng ngọt ngào, nơi mỗi hành vi có thể được diễn đạt theo mười cách khác nhau? Các ngôn ngữ thành công tồn tại ở mọi điểm trên phổ này.</p>
<p>Ở cực tối giản là những ngôn ngữ có cú pháp tối thiểu đến mức khắc nghiệt như Lisp, Forth và Smalltalk. Dân Lisp nổi tiếng với câu “ngôn ngữ của họ không có cú pháp”, trong khi dân Smalltalk tự hào cho thấy bạn có thể nhét toàn bộ grammar lên một tấm thẻ ghi chú. Trường phái này tin rằng <em>ngôn ngữ</em> không cần syntactic sugar. Thay vào đó, cú pháp và semantics tối giản mà nó cung cấp đủ mạnh để code trong thư viện có thể biểu đạt như thể nó là một phần của ngôn ngữ.</p>
<p>Gần đó là các ngôn ngữ như C, Lua và Go. Chúng hướng tới sự đơn giản và rõ ràng hơn là tối giản tuyệt đối. Một số, như Go, cố tình tránh cả syntactic sugar lẫn khả năng mở rộng cú pháp như nhóm trước. Chúng muốn cú pháp không cản trở semantics, nên tập trung giữ cho cả grammar và thư viện đơn giản. Code nên rõ ràng hơn là đẹp đẽ.</p>
<p>Ở khoảng giữa, bạn có các ngôn ngữ như Java, C# và Python. Rồi dần dần bạn sẽ gặp Ruby, C++, Perl và D — những ngôn ngữ nhồi nhét quá nhiều cú pháp vào grammar đến mức gần như hết ký tự dấu câu trên bàn phím.</p>
<p>Ở một mức độ nào đó, vị trí trên phổ này có liên quan đến tuổi đời. Việc thêm chút syntactic sugar ở các bản phát hành sau tương đối dễ dàng. Cú pháp mới thường được đón nhận, và ít có khả năng phá vỡ chương trình hiện có hơn so với việc thay đổi semantics. Một khi đã thêm vào, bạn không thể gỡ bỏ, nên các ngôn ngữ có xu hướng “ngọt” dần theo thời gian. Một trong những lợi ích lớn của việc tạo ra một ngôn ngữ mới từ đầu là bạn có cơ hội cạo bỏ những lớp “kem” tích tụ và bắt đầu lại.</p>
<p>Syntactic sugar thường bị giới PL intelligentsia đánh giá thấp. Có một “niềm đam mê” thực sự với chủ nghĩa tối giản trong nhóm này. Điều đó cũng có lý do: cú pháp được thiết kế kém, không cần thiết sẽ làm tăng gánh nặng nhận thức mà không thêm đủ khả năng biểu đạt để xứng đáng. Vì luôn có áp lực nhồi nhét tính năng mới vào ngôn ngữ, cần có kỷ luật và tập trung vào sự đơn giản để tránh phình to. Một khi đã thêm cú pháp, bạn sẽ phải sống chung với nó, nên tốt nhất là tiết kiệm.</p>
<p>Đồng thời, hầu hết các ngôn ngữ thành công đều có grammar khá phức tạp, ít nhất là khi chúng được sử dụng rộng rãi. Lập trình viên dành rất nhiều thời gian trong ngôn ngữ họ chọn, và một vài tiện ích nhỏ ở đây đó thực sự có thể cải thiện sự thoải mái và hiệu quả công việc.</p>
<p>Tìm được sự cân bằng hợp lý — chọn mức độ “ngọt” phù hợp cho ngôn ngữ của bạn — phụ thuộc vào gu thẩm mỹ của chính bạn.</p>
</div>

<footer>
<a href="functions.html" class="next">
  Đọc tiếp Chapter: &ldquo;Functions&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
