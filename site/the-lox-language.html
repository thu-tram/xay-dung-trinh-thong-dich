<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>The Lox Language &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">The Lox Language<small>3</small></a></h3>

<ul>
    <li><a href="#hello-lox"><small>3.1</small> Hello, Lox</a></li>
    <li><a href="#a-high-level-language"><small>3.2</small> A High-Level Language</a></li>
    <li><a href="#data-types"><small>3.3</small> Data Types</a></li>
    <li><a href="#expressions"><small>3.4</small> Expressions</a></li>
    <li><a href="#statements"><small>3.5</small> Statements</a></li>
    <li><a href="#variables"><small>3.6</small> Variables</a></li>
    <li><a href="#control-flow"><small>3.7</small> Control Flow</a></li>
    <li><a href="#functions"><small>3.8</small> Functions</a></li>
    <li><a href="#classes"><small>3.9</small> Classes</a></li>
    <li><a href="#the-standard-library"><small>3.10</small> The Standard Library</a></li>
    <li><a href="#thử-thách"><small>3.11</small> Thử thách</a></li>
    <li><a href="#ghi-chú-thiết-kế-expressions-&amp;-statements"><small>3.12</small> Ghi chú thiết kế: Expressions &amp; Statements</a></li>
</ul>


<div class="prev-next">
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="left">&larr;&nbsp;Chương trước</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="prev">←</a>
<a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="contents.html"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">The Lox Language<small>3</small></a></h3>

<ul>
    <li><a href="#hello-lox"><small>3.1</small> Hello, Lox</a></li>
    <li><a href="#a-high-level-language"><small>3.2</small> A High-Level Language</a></li>
    <li><a href="#data-types"><small>3.3</small> Data Types</a></li>
    <li><a href="#expressions"><small>3.4</small> Expressions</a></li>
    <li><a href="#statements"><small>3.5</small> Statements</a></li>
    <li><a href="#variables"><small>3.6</small> Variables</a></li>
    <li><a href="#control-flow"><small>3.7</small> Control Flow</a></li>
    <li><a href="#functions"><small>3.8</small> Functions</a></li>
    <li><a href="#classes"><small>3.9</small> Classes</a></li>
    <li><a href="#the-standard-library"><small>3.10</small> The Standard Library</a></li>
    <li><a href="#thử-thách"><small>3.11</small> Thử thách</a></li>
    <li><a href="#ghi-chú-thiết-kế-expressions-&amp;-statements"><small>3.12</small> Ghi chú thiết kế: Expressions &amp; Statements</a></li>
</ul>


<div class="prev-next">
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="left">&larr;&nbsp;Chương trước</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="right">Chương sau&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">3</div>
  <h1>The Lox Language</h1>

<blockquote>
<p>Có gì tuyệt vời hơn việc bạn làm bữa sáng cho ai đó?</p>
<p><cite>Anthony Bourdain</cite></p>
</blockquote>
<p>Chúng ta sẽ dành phần còn lại của cuốn sách này để soi sáng mọi ngóc ngách, dù tối tăm hay kỳ lạ, của ngôn ngữ Lox. Nhưng sẽ thật tàn nhẫn nếu bắt bạn ngay lập tức cắm đầu viết code cho interpreter mà chưa cho bạn thấy trước một chút về thứ mà chúng ta sẽ tạo ra.</p>
<p>Đồng thời, tôi cũng không muốn lôi bạn qua hàng đống lý thuyết luật lệ ngôn ngữ và văn phong đặc tả khô khan trước khi bạn được chạm tay vào <span name="home">trình soạn thảo</span> của mình. Vì vậy, đây sẽ là một phần giới thiệu nhẹ nhàng, thân thiện về Lox. Nó sẽ bỏ qua nhiều chi tiết và các trường hợp đặc biệt. Chúng ta sẽ có plenty of time để bàn về chúng sau.</p>
<aside name="home">
<p>Một hướng dẫn sẽ chẳng vui chút nào nếu bạn không thể tự mình thử code. Tiếc là, bạn chưa có interpreter cho Lox, vì bạn chưa xây dựng nó!</p>
<p>Đừng lo. Bạn có thể dùng <a href="https://github.com/munificent/craftinginterpreters">của tôi</a>.</p>
</aside>
<h2><a href="#hello-lox" id="hello-lox"><small>3&#8202;.&#8202;1</small>Hello, Lox</a></h2>
<p>Đây là “miếng nếm” đầu tiên của bạn với <span name="salmon">Lox</span>:</p>
<aside name="salmon">
<p>Ý tôi là “nếm” Lox — ngôn ngữ lập trình ấy. Tôi không biết bạn đã từng ăn cá hồi xông khói lạnh chưa. Nếu chưa, bạn cũng nên thử món đó.</p>
</aside>
<div class="codehilite"><pre><span class="c">// Your first Lox program!</span>
<span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>;
</pre></div>
<p>Như dòng comment <code>//</code> và dấu chấm phẩy ở cuối gợi ý, cú pháp của Lox thuộc họ C. (Không có dấu ngoặc đơn quanh chuỗi vì <code>print</code> là một câu lệnh built-in, không phải hàm trong thư viện.)</p>
<p>Giờ, tôi sẽ không nói rằng <span name="c">C</span> có cú pháp <em>tuyệt vời</em>. Nếu muốn thứ gì đó thanh lịch, có lẽ ta sẽ bắt chước Pascal hoặc Smalltalk. Nếu muốn tối giản kiểu “nội thất Bắc Âu”, ta sẽ chọn Scheme. Mỗi cái đều có ưu điểm riêng.</p>
<aside name="c">
<p>Tôi chắc chắn là có phần thiên vị, nhưng tôi nghĩ cú pháp của Lox khá gọn gàng. Những vấn đề ngữ pháp tệ nhất của C thường xoay quanh kiểu dữ liệu. Dennis Ritchie từng có ý tưởng gọi là “<a href="http://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way">declaration reflects use</a>”, nghĩa là khai báo biến phản ánh các thao tác bạn cần thực hiện trên biến đó để lấy ra giá trị kiểu cơ bản. Ý tưởng thông minh đấy, nhưng tôi không nghĩ nó hoạt động tốt trong thực tế.</p>
<p>Lox không có static types, nên chúng ta tránh được vấn đề này.</p>
</aside>
<p>Điều mà cú pháp giống C mang lại — và thường rất giá trị trong một ngôn ngữ — là <em>sự quen thuộc</em>. Tôi biết bạn đã quen với phong cách này, vì hai ngôn ngữ mà chúng ta sẽ dùng để <em>cài đặt</em> Lox — Java và C — cũng kế thừa nó. Dùng cú pháp tương tự cho Lox giúp bạn bớt đi một thứ phải học.</p>
<h2><a href="#a-high-level-language" id="a-high-level-language"><small>3&#8202;.&#8202;2</small>A High-Level Language</a></h2>
<p>Dù cuốn sách này đã dài hơn tôi mong muốn, nó vẫn không đủ chỗ để chứa một ngôn ngữ khổng lồ như Java. Để có thể đưa vào hai bản cài đặt hoàn chỉnh của Lox, bản thân Lox phải khá gọn nhẹ.</p>
<p>Khi nghĩ về những ngôn ngữ nhỏ nhưng hữu ích, tôi nhớ đến các ngôn ngữ “scripting” bậc cao như <span name="js">JavaScript</span>, Scheme và Lua. Trong ba cái đó, Lox trông giống JavaScript nhất, chủ yếu vì hầu hết các ngôn ngữ cú pháp C đều như vậy. Như chúng ta sẽ thấy sau, cách Lox xử lý scoping lại gần với Scheme. Phiên bản Lox viết bằng C mà chúng ta sẽ xây dựng trong <a href="a-bytecode-virtual-machine.html">Part III</a> chịu ảnh hưởng lớn từ cách cài đặt gọn gàng, hiệu quả của Lua.</p>
<aside name="js">
<p>Giờ đây JavaScript đã “thống trị thế giới” và được dùng để xây dựng những ứng dụng khổng lồ, thật khó để nghĩ về nó như một “ngôn ngữ scripting nhỏ bé”. Nhưng Brendan Eich đã viết bản interpreter JS đầu tiên cho Netscape Navigator chỉ trong <em>mười ngày</em> để làm các nút bấm trên trang web biết… nhảy múa. JavaScript đã trưởng thành nhiều từ đó, nhưng từng có thời nó chỉ là một ngôn ngữ dễ thương, nhỏ gọn.</p>
<p>Vì Eich “chắp vá” JS từ nguyên liệu thô sơ và thời gian ít ỏi chẳng khác gì một tập MacGyver, nên nó có vài góc cạnh ngữ nghĩa kỳ quặc, nơi mà “băng keo” và “kẹp giấy” lộ ra. Ví dụ như variable hoisting, <code>this</code> được bind động, mảng có lỗ, và các phép chuyển đổi ngầm.</p>
<p>Tôi thì có thời gian thong thả hơn khi làm Lox, nên nó sẽ sạch sẽ hơn một chút.</p>
</aside>
<p>Lox còn chia sẻ hai đặc điểm khác với ba ngôn ngữ kia:</p>
<h3><a href="#dynamic-typing" id="dynamic-typing"><small>3&#8202;.&#8202;2&#8202;.&#8202;1</small>Dynamic typing</a></h3>
<p>Lox là ngôn ngữ dynamic typing. Biến có thể lưu giá trị thuộc bất kỳ kiểu nào, và một biến thậm chí có thể lưu các giá trị thuộc kiểu khác nhau ở những thời điểm khác nhau. Nếu bạn thử thực hiện một phép toán trên các giá trị sai kiểu — ví dụ, chia một số cho một chuỗi — thì lỗi sẽ được phát hiện và báo ngay tại runtime.</p>
<p>Có rất nhiều lý do để thích <span name="static">static</span> types, nhưng chúng không đủ để vượt qua những lý do thực dụng khi chọn dynamic types cho Lox. Hệ thống static type tốn rất nhiều công sức để học và cài đặt. Bỏ qua nó giúp ngôn ngữ đơn giản hơn và cuốn sách ngắn hơn. Chúng ta sẽ có interpreter chạy được code sớm hơn nếu dời việc kiểm tra kiểu sang runtime.</p>
<aside name="static">
<p>Suy cho cùng, hai ngôn ngữ mà chúng ta sẽ dùng để <em>cài đặt</em> Lox đều là statically typed.</p>
</aside>
<h3><a href="#automatic-memory-management" id="automatic-memory-management"><small>3&#8202;.&#8202;2&#8202;.&#8202;2</small>Automatic memory management</a></h3>
<p>Các ngôn ngữ bậc cao ra đời để loại bỏ những công việc tẻ nhạt, dễ gây lỗi ở mức thấp, và còn gì nhàm chán hơn việc phải tự tay quản lý cấp phát và giải phóng bộ nhớ? Chẳng ai thức dậy và chào đón ánh mặt trời buổi sáng với câu: “Hôm nay mình nóng lòng muốn tìm đúng chỗ để gọi <code>free()</code> cho từng byte bộ nhớ mình cấp phát quá!”</p>
<p>Có hai <span name="gc">kỹ thuật</span> chính để quản lý bộ nhớ: <strong>reference counting</strong> và <strong>tracing garbage collection</strong> (thường được gọi ngắn gọn là <strong>garbage collection</strong> hoặc <strong>GC</strong>). Reference counting đơn giản hơn nhiều để cài đặt — tôi nghĩ đó là lý do Perl, PHP và Python ban đầu đều dùng nó. Nhưng theo thời gian, những hạn chế của reference counting trở nên quá phiền toái. Tất cả các ngôn ngữ đó cuối cùng đều phải bổ sung một tracing GC đầy đủ, hoặc ít nhất là đủ để dọn dẹp các vòng tham chiếu giữa các object.</p>
<aside name="gc">
<p>Trên thực tế, reference counting và tracing giống như hai đầu của một phổ liên tục hơn là hai thái cực đối lập. Hầu hết các hệ thống reference counting cuối cùng cũng phải làm một chút tracing để xử lý vòng lặp, và các write barrier của một generational collector nếu nhìn kỹ cũng hơi giống các lệnh retain.</p>
<p>Để tìm hiểu sâu hơn, hãy xem “<a href="https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf">A Unified Theory of Garbage Collection</a>” (PDF).</p>
</aside>
<p>Tracing garbage collection có tiếng là “đáng sợ”. Quả thật, làm việc ở mức bộ nhớ thô cũng hơi rùng mình. Debug một GC đôi khi khiến bạn thấy cả các bản dump hex trong giấc mơ. Nhưng hãy nhớ, cuốn sách này là để xua tan “ma thuật” và hạ gục những con quái vật đó, nên chúng ta <em>sẽ</em> tự viết một garbage collector. Tôi nghĩ bạn sẽ thấy thuật toán này khá đơn giản và rất thú vị để cài đặt.</p>
<h2><a href="#data-types" id="data-types"><small>3&#8202;.&#8202;3</small>Data Types</a></h2>
<p>Trong “vũ trụ” nhỏ bé của Lox, những nguyên tử tạo nên mọi thứ chính là các kiểu dữ liệu built-in. Chỉ có vài loại thôi:</p>
<ul>
<li>
<p><strong><span name="bool">Booleans</span>.</strong> Bạn không thể lập trình nếu thiếu logic, và cũng không thể có logic nếu thiếu Boolean. “True” và “false” — âm và dương của phần mềm. Không giống một số ngôn ngữ cổ xưa tái sử dụng một kiểu dữ liệu có sẵn để biểu diễn đúng/sai, Lox có một kiểu Boolean riêng biệt. Chúng ta có thể đang “dã chiến” trong chuyến phiêu lưu này, nhưng không phải <em>mọi rợ</em>.</p>
<aside name="bool">
<p>Boolean là kiểu dữ liệu duy nhất trong Lox được đặt theo tên một người — George Boole — nên “Boolean” được viết hoa. Ông mất năm 1864, gần một thế kỷ trước khi máy tính số biến đại số của ông thành điện tử. Tôi tự hỏi nếu ông thấy tên mình xuất hiện trong hàng tỷ dòng code Java thì sẽ nghĩ gì.</p>
</aside>
<p>Có hai giá trị Boolean, tất nhiên rồi, và mỗi giá trị có một literal riêng.</p>
<div class="codehilite"><pre><span class="k">true</span>;  <span class="c">// Not false.</span>
<span class="k">false</span>; <span class="c">// Not *not* false.</span>
</pre></div>
</li>
<li>
<p><strong>Numbers.</strong> Lox chỉ có một loại số: số thực dấu chấm động double-precision. Vì số thực dấu chấm động cũng có thể biểu diễn một dải rộng các số nguyên, nên nó bao quát khá nhiều trường hợp, đồng thời giữ mọi thứ đơn giản.</p>
<p>Các ngôn ngữ đầy đủ tính năng thường có nhiều cú pháp cho số — hệ thập lục phân, ký hiệu khoa học, bát phân, đủ kiểu thú vị. Chúng ta sẽ chỉ dùng literal số nguyên và số thập phân cơ bản.</p>
<div class="codehilite"><pre><span class="n">1234</span>;  <span class="c">// An integer.</span>
<span class="n">12.34</span>; <span class="c">// A decimal number.</span>
</pre></div>
</li>
<li>
<p><strong>Strings.</strong> Chúng ta đã thấy một string literal trong ví dụ đầu tiên. Giống hầu hết các ngôn ngữ, chúng được đặt trong dấu ngoặc kép.</p>
<div class="codehilite"><pre><span class="s">&quot;I am a string&quot;</span>;
<span class="s">&quot;&quot;</span>;    <span class="c">// The empty string.</span>
<span class="s">&quot;123&quot;</span>; <span class="c">// This is a string, not a number.</span>
</pre></div>
<p>Như chúng ta sẽ thấy khi cài đặt, có khá nhiều phức tạp ẩn sau chuỗi <span name="char">character</span> tưởng chừng vô hại này.</p>
<aside name="char">
<p>Ngay cả từ “character” cũng là một kẻ đánh lừa. Nó là ASCII? Unicode? Một code point hay một “grapheme cluster”? Các ký tự được mã hóa thế nào? Mỗi ký tự có kích thước cố định hay thay đổi?</p>
</aside></li>
<li>
<p><strong>Nil.</strong> Có một giá trị built-in cuối cùng, chẳng bao giờ được mời nhưng luôn xuất hiện. Nó biểu diễn “không có giá trị”. Trong nhiều ngôn ngữ khác, nó được gọi là “null”. Trong Lox, ta viết là <code>nil</code>. (Khi cài đặt, điều này sẽ giúp phân biệt khi nào ta nói về <code>nil</code> của Lox so với <code>null</code> của Java hoặc C.)</p>
<p>Có nhiều lý lẽ để loại bỏ null khỏi một ngôn ngữ, vì lỗi null pointer là “tai họa” của ngành. Nếu chúng ta làm một ngôn ngữ static typing, có lẽ sẽ đáng để thử cấm nó. Nhưng trong một ngôn ngữ dynamic typing, loại bỏ nó thường gây phiền toái hơn là giữ lại.</p>
</li>
</ul>
<h2><a href="#expressions" id="expressions"><small>3&#8202;.&#8202;4</small>Expressions</a></h2>
<p>Nếu các kiểu dữ liệu built-in và literal của chúng là nguyên tử, thì <strong>expressions</strong> chính là các phân tử. Phần lớn trong số này sẽ quen thuộc với bạn.</p>
<h3><a href="#arithmetic" id="arithmetic"><small>3&#8202;.&#8202;4&#8202;.&#8202;1</small>Arithmetic</a></h3>
<p>Lox có các toán tử số học cơ bản mà bạn biết và yêu thích từ C và các ngôn ngữ khác:</p>
<div class="codehilite"><pre><span class="i">add</span> + <span class="i">me</span>;
<span class="i">subtract</span> - <span class="i">me</span>;
<span class="i">multiply</span> * <span class="i">me</span>;
<span class="i">divide</span> / <span class="i">me</span>;
</pre></div>
<p>Các biểu thức con ở hai bên toán tử gọi là <strong>operands</strong>. Vì có <em>hai</em> toán hạng, nên chúng được gọi là toán tử <strong>binary</strong>. (Điều này không liên quan gì đến nghĩa “nhị phân” kiểu 0 và 1.) Vì toán tử được <span name="fixity">cố định</span> <em>ở giữa</em> các toán hạng, nên chúng còn được gọi là toán tử <strong>infix</strong> (trái ngược với <strong>prefix</strong> — toán tử đứng trước toán hạng, và <strong>postfix</strong> — toán tử đứng sau).</p>
<aside name="fixity">
<p>Có một số toán tử có nhiều hơn hai toán hạng và toán tử được xen kẽ giữa chúng. Toán tử duy nhất được dùng rộng rãi là toán tử “điều kiện” hay “ternary” của C và các ngôn ngữ họ hàng:</p>
<div class="codehilite"><pre><span class="i">condition</span> ? <span class="i">thenArm</span> : <span class="i">elseArm</span>;
</pre></div>
<p>Một số người gọi chúng là toán tử <strong>mixfix</strong>. Một vài ngôn ngữ cho phép bạn định nghĩa toán tử riêng và điều khiển vị trí của chúng — tức “fixity”.</p>
</aside>
<p>Một toán tử số học thực ra vừa là infix vừa là prefix: dấu <code>-</code> cũng có thể dùng để lấy số đối.</p>
<div class="codehilite"><pre>-<span class="i">negateMe</span>;
</pre></div>
<p>Tất cả các toán tử này hoạt động trên số, và sẽ báo lỗi nếu truyền kiểu khác. Ngoại lệ duy nhất là toán tử <code>+</code> — bạn cũng có thể truyền cho nó hai chuỗi để nối chúng lại.</p>
<h3><a href="#comparison-and-equality" id="comparison-and-equality"><small>3&#8202;.&#8202;4&#8202;.&#8202;2</small>Comparison and equality</a></h3>
<p>Tiếp tục nào, chúng ta có thêm vài toán tử nữa luôn trả về kết quả Boolean.<br />
Ta có thể so sánh các số (và <strong>chỉ</strong> số) bằng những “toán tử so sánh cổ điển”:</p>
<div class="codehilite"><pre><span class="i">less</span> &lt; <span class="i">than</span>;
<span class="i">lessThan</span> &lt;= <span class="i">orEqual</span>;
<span class="i">greater</span> &gt; <span class="i">than</span>;
<span class="i">greaterThan</span> &gt;= <span class="i">orEqual</span>;
</pre></div>
<p>Ta có thể kiểm tra hai giá trị bất kỳ xem chúng bằng nhau hay khác nhau:</p>
<div class="codehilite"><pre><span class="n">1</span> == <span class="n">2</span>;         <span class="c">// false.</span>
<span class="s">&quot;cat&quot;</span> != <span class="s">&quot;dog&quot;</span>; <span class="c">// true.</span>
</pre></div>
<p>Thậm chí là khác kiểu:</p>
<div class="codehilite"><pre><span class="n">314</span> == <span class="s">&quot;pi&quot;</span>; <span class="c">// false.</span>
</pre></div>
<p>Các giá trị khác kiểu <em>không bao giờ</em> được coi là tương đương:</p>
<div class="codehilite"><pre><span class="n">123</span> == <span class="s">&quot;123&quot;</span>; <span class="c">// false.</span>
</pre></div>
<p>Nói chung, tôi không thích các phép chuyển đổi ngầm định.</p>
<h3><a href="#logical-operators" id="logical-operators"><small>3&#8202;.&#8202;4&#8202;.&#8202;3</small>Logical operators</a></h3>
<p>Toán tử not, dạng prefix <code>!</code>, trả về <code>false</code> nếu toán hạng của nó là true, và ngược lại.</p>
<div class="codehilite"><pre>!<span class="k">true</span>;  <span class="c">// false.</span>
!<span class="k">false</span>; <span class="c">// true.</span>
</pre></div>
<p>Hai toán tử logic còn lại thực chất là các cấu trúc điều khiển trá hình dưới dạng biểu thức.<br />
Biểu thức <span name="and"><code>and</code></span> kiểm tra xem <em>cả hai</em> giá trị có đều true hay không. Nó trả về toán hạng bên trái nếu toán hạng đó là false, hoặc trả về toán hạng bên phải nếu không.</p>
<div class="codehilite"><pre><span class="k">true</span> <span class="k">and</span> <span class="k">false</span>; <span class="c">// false.</span>
<span class="k">true</span> <span class="k">and</span> <span class="k">true</span>;  <span class="c">// true.</span>
</pre></div>
<p>Còn biểu thức <code>or</code> kiểm tra xem <em>ít nhất một</em> trong hai giá trị (hoặc cả hai) có true hay không. Nó trả về toán hạng bên trái nếu toán hạng đó là true, và trả về toán hạng bên phải nếu không.</p>
<div class="codehilite"><pre><span class="k">false</span> <span class="k">or</span> <span class="k">false</span>; <span class="c">// false.</span>
<span class="k">true</span> <span class="k">or</span> <span class="k">false</span>;  <span class="c">// true.</span>
</pre></div>
<aside name="and">
<p>Tôi dùng <code>and</code> và <code>or</code> thay vì <code>&amp;&amp;</code> và <code>||</code> vì Lox không dùng <code>&amp;</code> và <code>|</code> cho các toán tử bitwise. Sẽ thấy kỳ cục nếu đưa vào dạng hai ký tự mà không có dạng một ký tự.</p>
<p>Tôi cũng khá thích dùng từ khóa cho chúng vì thực chất đây là các cấu trúc điều khiển luồng, không chỉ là toán tử đơn giản.</p>
</aside>
<p>Lý do <code>and</code> và <code>or</code> giống cấu trúc điều khiển là vì chúng <strong>short-circuit</strong>. Không chỉ <code>and</code> trả về toán hạng bên trái nếu nó là false, mà trong trường hợp đó nó còn <em>không thèm</em> đánh giá toán hạng bên phải. Ngược lại (hay nói theo kiểu phản chứng?), nếu toán hạng bên trái của <code>or</code> là true, toán hạng bên phải sẽ bị bỏ qua.</p>
<h3><a href="#precedence-and-grouping" id="precedence-and-grouping"><small>3&#8202;.&#8202;4&#8202;.&#8202;4</small>Precedence and grouping</a></h3>
<p>Tất cả các toán tử này có độ ưu tiên (precedence) và tính kết hợp (associativity) giống như bạn mong đợi từ C. (Khi đến phần parsing, chúng ta sẽ nói <em>cực kỳ</em> chi tiết về chuyện này.) Trong những trường hợp độ ưu tiên không như ý, bạn có thể dùng <code>()</code> để nhóm lại.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">average</span> = (<span class="i">min</span> + <span class="i">max</span>) / <span class="n">2</span>;
</pre></div>
<p>Vì chúng không quá thú vị về mặt kỹ thuật, tôi đã lược bỏ phần còn lại của “bộ sưu tập” toán tử thường thấy khỏi ngôn ngữ nhỏ bé của chúng ta. Không có bitwise, shift, modulo hay toán tử điều kiện. Tôi không chấm điểm bạn, nhưng bạn sẽ được cộng điểm trong lòng tôi nếu tự bổ sung chúng vào bản cài đặt Lox của mình.</p>
<p>Đó là các dạng expression (trừ một vài dạng liên quan đến các tính năng cụ thể mà ta sẽ gặp sau), nên giờ hãy lên một cấp độ.</p>
<h2><a href="#statements" id="statements"><small>3&#8202;.&#8202;5</small>Statements</a></h2>
<p>Giờ chúng ta đến với statements. Nếu nhiệm vụ chính của một expression là tạo ra một <em>giá trị</em>, thì nhiệm vụ của một statement là tạo ra một <em>tác động</em>. Vì theo định nghĩa, statements không trả về giá trị, nên để hữu ích, chúng phải thay đổi “thế giới” theo cách nào đó — thường là thay đổi trạng thái, đọc input hoặc tạo output.</p>
<p>Bạn đã thấy vài loại statement rồi. Loại đầu tiên là:</p>
<div class="codehilite"><pre><span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>;
</pre></div>
<p>Một <span name="print"><code>print</code> statement</span> sẽ đánh giá một expression duy nhất và hiển thị kết quả cho người dùng. Bạn cũng đã thấy vài statement như:</p>
<aside name="print">
<p>Đưa <code>print</code> vào thẳng ngôn ngữ thay vì chỉ làm nó thành một hàm trong core library là một “mánh”. Nhưng đây là một mánh <em>hữu ích</em> cho chúng ta: nó cho phép interpreter đang xây dựng có thể tạo ra output trước khi chúng ta cài đặt toàn bộ cơ chế để định nghĩa hàm, tìm chúng theo tên và gọi chúng.</p>
</aside>
<div class="codehilite"><pre><span class="s">&quot;some expression&quot;</span>;
</pre></div>
<p>Một expression theo sau bởi dấu chấm phẩy (<code>;</code>) sẽ được “nâng cấp” thành một statement. Cái này được gọi (một cách khá… tưởng tượng) là <strong>expression statement</strong>.</p>
<p>Nếu bạn muốn gói một loạt statement vào chỗ mà chỉ một statement được mong đợi, bạn có thể bọc chúng trong một <strong>block</strong>.</p>
<div class="codehilite"><pre>{
  <span class="k">print</span> <span class="s">&quot;One statement.&quot;</span>;
  <span class="k">print</span> <span class="s">&quot;Two statements.&quot;</span>;
}
</pre></div>
<p>Block cũng ảnh hưởng đến phạm vi (scope), và điều đó dẫn chúng ta đến phần tiếp theo<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#variables" id="variables"><small>3&#8202;.&#8202;6</small>Variables</a></h2>
<p>Bạn khai báo biến bằng <code>var</code> statement. Nếu bạn <span name="omit">bỏ qua</span> phần khởi tạo, giá trị của biến sẽ mặc định là <code>nil</code>.</p>
<aside name="omit">
<p>Đây là một trong những trường hợp mà việc không có <code>nil</code> và buộc mọi biến phải được khởi tạo với một giá trị nào đó sẽ gây phiền toái hơn là việc chấp nhận <code>nil</code>.</p>
</aside>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">imAVariable</span> = <span class="s">&quot;here is my value&quot;</span>;
<span class="k">var</span> <span class="i">iAmNil</span>;
</pre></div>
<p>Sau khi khai báo, tất nhiên, bạn có thể truy cập và gán giá trị cho biến bằng tên của nó.</p>
<p><span name="breakfast"></span></p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;bagels&quot;</span>;
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;bagels&quot;.</span>
<span class="i">breakfast</span> = <span class="s">&quot;beignets&quot;</span>;
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;beignets&quot;.</span>
</pre></div>
<aside name="breakfast">
<p>Bạn có nhận ra là tôi thường làm việc với cuốn sách này vào buổi sáng trước khi ăn gì không?</p>
</aside>
<p>Tôi sẽ không đi sâu vào các quy tắc về phạm vi biến ở đây, vì chúng ta sẽ dành khá nhiều thời gian ở các chương sau để “vẽ bản đồ” từng ngóc ngách của các quy tắc đó. Trong hầu hết các trường hợp, nó hoạt động giống như bạn mong đợi khi đến từ C hoặc Java.</p>
<h2><a href="#control-flow" id="control-flow"><small>3&#8202;.&#8202;7</small>Control Flow</a></h2>
<p>Thật khó để viết các chương trình <span name="flow">hữu ích</span> nếu bạn không thể bỏ qua một số đoạn code hoặc execute một số đoạn nhiều lần. Đó chính là control flow. Ngoài các toán tử logic mà ta đã nói, Lox lấy nguyên ba loại statement từ C.</p>
<aside name="flow">
<p>Chúng ta đã có <code>and</code> và <code>or</code> để rẽ nhánh, và <em>có thể</em> dùng đệ quy để lặp lại code, nên về lý thuyết là đủ. Nhưng lập trình theo kiểu đó trong một ngôn ngữ mang phong cách mệnh lệnh sẽ khá gượng gạo.</p>
<p>Scheme, ngược lại, không có cấu trúc vòng lặp built-in. Nó <em>thực sự</em> dựa vào đệ quy để lặp. Smalltalk thì không có cấu trúc rẽ nhánh built-in, và dựa vào dynamic dispatch để chọn lọc execute code.</p>
</aside>
<p>Một <code>if</code> statement sẽ execute một trong hai statement dựa trên điều kiện.</p>
<div class="codehilite"><pre><span class="k">if</span> (<span class="i">condition</span>) {
  <span class="k">print</span> <span class="s">&quot;yes&quot;</span>;
} <span class="k">else</span> {
  <span class="k">print</span> <span class="s">&quot;no&quot;</span>;
}
</pre></div>
<p>Một vòng lặp <code>while</code> <span name="do">loop</span> sẽ execute phần thân lặp đi lặp lại miễn là biểu thức điều kiện vẫn true.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">while</span> (<span class="i">a</span> &lt; <span class="n">10</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>;
}
</pre></div>
<aside name="do">
<p>Tôi bỏ <code>do while</code> loop ra khỏi Lox vì chúng không phổ biến lắm và cũng không dạy bạn điều gì mà bạn chưa học được từ <code>while</code>. Cứ thoải mái thêm nó vào bản cài đặt của bạn nếu bạn thích. Đây là “bữa tiệc” của bạn mà.</p>
</aside>
<p>Cuối cùng, chúng ta có vòng lặp <code>for</code>.</p>
<div class="codehilite"><pre><span class="k">for</span> (<span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10</span>; <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>) {
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p>Vòng lặp này làm đúng những gì vòng <code>while</code> trước đó làm. Hầu hết các ngôn ngữ hiện đại cũng có dạng vòng lặp <span name="foreach"><code>for-in</code></span> hoặc <code>foreach</code> để duyệt qua các kiểu sequence khác nhau một cách rõ ràng. Trong một ngôn ngữ thực tế, điều đó “dễ chịu” hơn nhiều so với vòng <code>for</code> kiểu C thô sơ mà ta có ở đây. Lox thì giữ mọi thứ đơn giản.</p>
<aside name="foreach">
<p>Đây là một sự nhượng bộ tôi đưa ra vì cách mà phần cài đặt được chia theo chương. Một vòng <code>for-in</code> cần một dạng dynamic dispatch trong iterator protocol để xử lý các loại sequence khác nhau, nhưng chúng ta sẽ không có điều đó cho đến khi xong phần control flow. Chúng ta có thể quay lại và thêm vòng <code>for-in</code> sau, nhưng tôi không nghĩ việc đó sẽ dạy bạn điều gì quá thú vị.</p>
</aside>
<h2><a href="#functions" id="functions"><small>3&#8202;.&#8202;8</small>Functions</a></h2>
<p>Một biểu thức gọi hàm (function call expression) trong Lox trông giống hệt như trong C.</p>
<div class="codehilite"><pre><span class="i">makeBreakfast</span>(<span class="i">bacon</span>, <span class="i">eggs</span>, <span class="i">toast</span>);
</pre></div>
<p>Bạn cũng có thể gọi một hàm mà không truyền gì vào.</p>
<div class="codehilite"><pre><span class="i">makeBreakfast</span>();
</pre></div>
<p>Không giống như trong, chẳng hạn, Ruby, dấu ngoặc đơn là bắt buộc trong trường hợp này. Nếu bạn bỏ chúng đi, tên hàm sẽ không <em>gọi</em> hàm đó, mà chỉ đơn thuần tham chiếu tới nó.</p>
<p>Một ngôn ngữ sẽ chẳng thú vị mấy nếu bạn không thể tự định nghĩa hàm của mình. Trong Lox, bạn làm điều đó với <span name="fun"><code>fun</code></span>.</p>
<aside name="fun">
<p>Tôi đã thấy các ngôn ngữ dùng <code>fn</code>, <code>fun</code>, <code>func</code>, và <code>function</code>. Tôi vẫn hy vọng sẽ tìm thấy đâu đó một <code>funct</code>, <code>functi</code>, hoặc <code>functio</code>.</p>
</aside>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">printSum</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
}
</pre></div>
<p>Giờ là lúc thích hợp để làm rõ một chút về <span name="define">thuật ngữ</span>. Một số người dùng “parameter” và “argument” như thể chúng có thể thay thế cho nhau, và với nhiều người thì đúng là vậy. Nhưng chúng ta sẽ dành khá nhiều thời gian để mổ xẻ những chi tiết nhỏ nhất về ngữ nghĩa, nên hãy làm rõ từ ngữ. Từ đây trở đi:</p>
<ul>
<li>
<p><strong>Argument</strong> là giá trị thực tế bạn truyền vào hàm khi gọi nó. Vì vậy, một lần <em>gọi</em> hàm sẽ có một danh sách <em>argument</em>. Đôi khi bạn sẽ nghe thấy cụm <strong>actual parameter</strong> để chỉ chúng.</p>
</li>
<li>
<p><strong>Parameter</strong> là biến giữ giá trị của argument bên trong thân hàm. Do đó, một <em>khai báo</em> hàm sẽ có một danh sách <em>parameter</em>. Một số người gọi chúng là <strong>formal parameters</strong> hoặc đơn giản là <strong>formals</strong>.</p>
</li>
</ul>
<aside name="define">
<p>Nói về thuật ngữ, một số ngôn ngữ static typing như C phân biệt giữa <em>khai báo</em> (declare) hàm và <em>định nghĩa</em> (define) hàm. Khai báo sẽ gắn kiểu của hàm với tên của nó để các lời gọi có thể được kiểm tra kiểu, nhưng không cung cấp phần thân. Định nghĩa vừa khai báo hàm vừa viết phần thân để hàm có thể được biên dịch.</p>
<p>Vì Lox là dynamic typing, sự phân biệt này không có ý nghĩa. Một khai báo hàm trong Lox đã bao gồm đầy đủ phần thân.</p>
</aside>
<p>Phần thân của một hàm luôn là một block. Bên trong, bạn có thể trả về một giá trị bằng <code>return</code> statement.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">returnSum</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span>;
}
</pre></div>
<p>Nếu việc execute đi đến cuối block mà không gặp <code>return</code>, nó sẽ <span name="sneaky">ngầm định</span> trả về <code>nil</code>.</p>
<aside name="sneaky">
<p>Thấy chưa, tôi đã nói là <code>nil</code> sẽ lén xuất hiện khi ta không để ý mà.</p>
</aside>
<h3><a href="#closures" id="closures"><small>3&#8202;.&#8202;8&#8202;.&#8202;1</small>Closures</a></h3>
<p>Hàm trong Lox là <em>first class</em>, nghĩa là chúng là những giá trị thực sự mà bạn có thể lấy tham chiếu, lưu vào biến, truyền đi, v.v. Ví dụ này hoạt động:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">addPair</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span>;
}

<span class="k">fun</span> <span class="i">identity</span>(<span class="i">a</span>) {
  <span class="k">return</span> <span class="i">a</span>;
}

<span class="k">print</span> <span class="i">identity</span>(<span class="i">addPair</span>)(<span class="n">1</span>, <span class="n">2</span>); <span class="c">// Prints &quot;3&quot;.</span>
</pre></div>
<p>Vì khai báo hàm là một statement, bạn có thể khai báo hàm cục bộ bên trong một hàm khác.</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">outerFunction</span>() {
  <span class="k">fun</span> <span class="i">localFunction</span>() {
    <span class="k">print</span> <span class="s">&quot;I&#39;m local!&quot;</span>;
  }

  <span class="i">localFunction</span>();
}
</pre></div>
<p>Nếu bạn kết hợp hàm cục bộ, hàm first-class và block scope, bạn sẽ gặp tình huống thú vị này:</p>
<div class="codehilite"><pre><span class="k">fun</span> <span class="i">returnFunction</span>() {
  <span class="k">var</span> <span class="i">outside</span> = <span class="s">&quot;outside&quot;</span>;

  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">outside</span>;
  }

  <span class="k">return</span> <span class="i">inner</span>;
}

<span class="k">var</span> <span class="i">fn</span> = <span class="i">returnFunction</span>();
<span class="i">fn</span>();
</pre></div>
<p>Ở đây, <code>inner()</code> truy cập một biến cục bộ được khai báo bên ngoài thân của nó, trong hàm bao quanh. Điều này có hợp lệ không? Giờ khi nhiều ngôn ngữ đã mượn tính năng này từ Lisp, có lẽ bạn đã biết câu trả lời là “có”.</p>
<p>Để làm được điều đó, <code>inner()</code> phải “giữ lại” tham chiếu tới bất kỳ biến bao quanh nào mà nó sử dụng, để chúng vẫn tồn tại ngay cả sau khi hàm bên ngoài đã trả về. Chúng ta gọi những hàm làm điều này là <span name="closure"><strong>closures</strong></span>. Ngày nay, thuật ngữ này thường được dùng cho <em>bất kỳ</em> hàm first-class nào, dù thực ra hơi sai nếu hàm đó không “đóng” (close over) biến nào cả.</p>
<aside name="closure">
<p>Peter J. Landin là người đặt ra thuật ngữ &ldquo;closure&rdquo;. Vâng, ông ấy đã phát minh ra gần như một nửa số thuật ngữ trong lĩnh vực ngôn ngữ lập trình. Phần lớn trong số đó xuất phát từ một bài báo kinh điển, “<a href="https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/landin-next-700.pdf">The Next 700 Programming Languages</a>”.</p>
<p>Để cài đặt những loại hàm này, bạn cần tạo ra một cấu trúc dữ liệu gói chung cả phần code của hàm và các biến bao quanh mà nó cần. Ông gọi nó là &ldquo;closure&rdquo; vì nó <em>đóng gói</em> (close over) và giữ lại các biến cần thiết.</p>
</aside>
<p>Như bạn có thể hình dung, việc cài đặt chúng sẽ làm tăng độ phức tạp vì ta không thể giả định rằng phạm vi biến hoạt động hoàn toàn như một stack — nơi các biến cục bộ biến mất ngay khi hàm trả về. Chúng ta sẽ có một khoảng thời gian thú vị để học cách làm cho chúng hoạt động đúng và hiệu quả.</p>
<h2><a href="#classes" id="classes"><small>3&#8202;.&#8202;9</small>Classes</a></h2>
<p>Vì Lox có dynamic typing, lexical scope (nôm na là “block” scope) và closures, nó đã đi được nửa chặng đường để trở thành một ngôn ngữ lập trình hàm (functional language). Nhưng như bạn sẽ thấy, nó <em>cũng</em> đã đi được nửa chặng đường để trở thành một ngôn ngữ hướng đối tượng (object-oriented language). Cả hai mô hình đều có nhiều điểm mạnh, nên tôi nghĩ đáng để đề cập một chút về mỗi bên.</p>
<p>Vì classes gần đây bị chỉ trích là không đáp ứng được kỳ vọng, trước tiên hãy để tôi giải thích tại sao tôi đưa chúng vào Lox và vào cuốn sách này. Thực ra có hai câu hỏi:</p>
<h3><a href="#tại-sao-một-ngôn-ngữ-lại-muốn-hướng-đối-tượng" id="tại-sao-một-ngôn-ngữ-lại-muốn-hướng-đối-tượng"><small>3&#8202;.&#8202;9&#8202;.&#8202;1</small>Tại sao một ngôn ngữ lại muốn hướng đối tượng?</a></h3>
<p>Giờ đây, khi các ngôn ngữ hướng đối tượng như Java đã “bán hết vé” và chỉ diễn ở những sân khấu lớn, việc thích chúng không còn “ngầu” nữa. Vậy tại sao ai đó lại tạo ra một ngôn ngữ <em>mới</em> với objects? Chẳng phải điều đó giống như phát hành nhạc trên băng 8-track sao?</p>
<p>Đúng là “cơn sốt kế thừa mọi thứ” của thập niên 90 đã tạo ra những hệ thống class kế thừa khổng lồ và cồng kềnh, nhưng <strong>lập trình hướng đối tượng</strong> (<strong>OOP</strong>) vẫn rất tuyệt. Hàng tỷ dòng code thành công đã được viết bằng các ngôn ngữ OOP, đưa hàng triệu ứng dụng đến tay người dùng hài lòng. Có lẽ phần lớn lập trình viên hiện nay đang dùng một ngôn ngữ hướng đối tượng. Không thể tất cả họ đều <em>sai</em> được.</p>
<p>Đặc biệt, với một ngôn ngữ dynamic typing, objects rất hữu ích. Chúng ta cần <em>một cách nào đó</em> để định nghĩa các kiểu dữ liệu phức hợp nhằm gom nhiều thứ lại với nhau.</p>
<p>Nếu ta có thể gắn thêm methods vào đó, thì ta tránh được việc phải đặt tiền tố cho tất cả các hàm bằng tên kiểu dữ liệu mà chúng xử lý, nhằm tránh xung đột với các hàm tương tự cho kiểu khác. Ví dụ, trong Racket, bạn sẽ phải đặt tên hàm như <code>hash-copy</code> (để copy một hash table) và <code>vector-copy</code> (để copy một vector) để chúng không “dẫm chân” nhau. Methods được giới hạn phạm vi trong object, nên vấn đề đó biến mất.</p>
<h3><a href="#tại-sao-lox-lại-hướng-đối-tượng" id="tại-sao-lox-lại-hướng-đối-tượng"><small>3&#8202;.&#8202;9&#8202;.&#8202;2</small>Tại sao Lox lại hướng đối tượng?</a></h3>
<p>Tôi có thể nói rằng objects rất “ngầu” nhưng vẫn nằm ngoài phạm vi của cuốn sách. Hầu hết sách về ngôn ngữ lập trình, đặc biệt là những cuốn cố gắng cài đặt cả một ngôn ngữ, đều bỏ qua objects. Với tôi, điều đó có nghĩa là chủ đề này chưa được đề cập đầy đủ. Với một mô hình lập trình phổ biến như vậy, việc bỏ qua khiến tôi thấy tiếc.</p>
<p>Xét việc nhiều người trong chúng ta dành cả ngày <em>sử dụng</em> các ngôn ngữ OOP, có vẻ thế giới sẽ cần một chút tài liệu về cách <em>tạo ra</em> một ngôn ngữ như vậy. Như bạn sẽ thấy, hóa ra nó khá thú vị. Không khó như bạn lo, nhưng cũng không đơn giản như bạn tưởng.</p>
<h3><a href="#classes-hay-prototypes" id="classes-hay-prototypes"><small>3&#8202;.&#8202;9&#8202;.&#8202;3</small>Classes hay prototypes</a></h3>
<p>Khi nói đến objects, thực ra có hai cách tiếp cận: <a href="https://en.wikipedia.org/wiki/Class-based_programming">classes</a> và <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototypes</a>. Classes xuất hiện trước và phổ biến hơn nhờ C++, Java, C# và các “anh em” của chúng. Prototypes từng là một nhánh gần như bị lãng quên cho đến khi JavaScript vô tình “thống trị thế giới”.</p>
<p>Trong các ngôn ngữ dựa trên class, có hai khái niệm cốt lõi: instance và class. Instance lưu trữ trạng thái cho từng object và có tham chiếu đến class của instance đó. Class chứa các method và chuỗi kế thừa. Để gọi một method trên một instance, luôn có một bước gián tiếp. Bạn sẽ <span name="dispatch">tra cứu</span> class của instance đó rồi tìm method <em>ở đó</em>:</p>
<aside name="dispatch">
<p>Trong một ngôn ngữ static typing như C++, việc tìm method thường diễn ra ở thời điểm biên dịch dựa trên kiểu <em>tĩnh</em> của instance, cho bạn <strong>static dispatch</strong>. Ngược lại, <strong>dynamic dispatch</strong> sẽ tra cứu class của object thực tế tại runtime. Đây là cách các virtual method trong ngôn ngữ static typing và tất cả method trong ngôn ngữ dynamic typing như Lox hoạt động.</p>
</aside><img src="image/the-lox-language/class-lookup.png" alt="Cách tra cứu fields và methods trên classes và instances" />
<p>Các ngôn ngữ dựa trên prototype <span name="blurry">kết hợp</span> hai khái niệm này. Chỉ có objects — không có classes — và mỗi object riêng lẻ có thể chứa cả trạng thái và methods. Objects có thể kế thừa trực tiếp từ nhau (hoặc “ủy quyền” trong ngôn ngữ của prototype):</p>
<aside name="blurry">
<p>Trên thực tế, ranh giới giữa ngôn ngữ dựa trên class và dựa trên prototype khá mờ. Khái niệm “constructor function” của JavaScript <a href="http://gameprogrammingpatterns.com/prototype.html#what-about-javascript">đẩy bạn khá mạnh</a> theo hướng định nghĩa các object giống class. Trong khi đó, Ruby dựa trên class lại hoàn toàn thoải mái cho phép bạn gắn methods vào từng instance riêng lẻ.</p>
</aside><img src="image/the-lox-language/prototype-lookup.png" alt="How fields and methods are looked up in a prototypal system" />
<p>Điều này có nghĩa là, theo một số khía cạnh, các ngôn ngữ dựa trên prototype mang tính nền tảng hơn so với classes. Chúng thực sự rất “đã” khi cài đặt vì <em>quá</em> đơn giản. Ngoài ra, chúng có thể biểu đạt nhiều mẫu thiết kế (pattern) khác thường mà classes thường hướng bạn tránh xa.</p>
<p>Nhưng tôi đã xem <em>rất nhiều</em> code viết bằng các ngôn ngữ dựa trên prototype — bao gồm cả <a href="http://finch.stuffwithstuff.com/">một số do chính tôi tạo ra</a>. Bạn có biết mọi người thường làm gì với tất cả sức mạnh và sự linh hoạt của prototypes không? …Họ dùng chúng để tái tạo lại classes.</p>
<p>Tôi không biết <em>tại sao</em> lại như vậy, nhưng dường như con người tự nhiên có xu hướng thích phong cách dựa trên class (Classic? Classy?). Prototypes <em>đúng là</em> đơn giản hơn trong ngôn ngữ, nhưng chúng dường như đạt được điều đó chỉ bằng cách <span name="waterbed">đẩy</span> phần phức tạp sang cho người dùng. Vậy nên, với Lox, chúng ta sẽ giúp người dùng đỡ vất vả và tích hợp sẵn classes vào.</p>
<aside name="waterbed">
<p>Larry Wall, “cha đẻ” kiêm “nhà tiên tri” của Perl, gọi đây là “<a href="http://wiki.c2.com/?WaterbedTheory">waterbed theory</a>”. Một số sự phức tạp là thiết yếu và không thể loại bỏ. Nếu bạn ấn nó xuống ở chỗ này, nó sẽ phồng lên ở chỗ khác.</p>
<p>Các ngôn ngữ dựa trên prototype không hẳn <em>loại bỏ</em> sự phức tạp của classes, mà là bắt <em>người dùng</em> gánh lấy sự phức tạp đó bằng cách tự xây dựng các thư viện metaprogramming giống class.</p>
</aside>
<h3><a href="#classes-trong-lox" id="classes-trong-lox"><small>3&#8202;.&#8202;9&#8202;.&#8202;4</small>Classes trong Lox</a></h3>
<p>Bấy nhiêu lý do là đủ rồi, giờ hãy xem chúng ta thực sự có gì. Trong hầu hết các ngôn ngữ, classes bao gồm một “chòm sao” các tính năng. Với Lox, tôi đã chọn ra những “ngôi sao” sáng nhất. Bạn khai báo một class và các method của nó như sau:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Eggs a-fryin&#39;!&quot;</span>;
  }

  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">&quot;Enjoy your breakfast, &quot;</span> + <span class="i">who</span> + <span class="s">&quot;.&quot;</span>;
  }
}
</pre></div>
<p>Phần thân của class chứa các method. Chúng trông giống như khai báo hàm nhưng không có từ khóa <code>fun</code> <span name="method">keyword</span>. Khi câu lệnh khai báo class được execute, Lox sẽ tạo ra một object class và lưu nó vào một biến có tên trùng với tên class. Giống như functions, classes cũng là first-class trong Lox.</p>
<aside name="method">
<p>Nhưng chúng vẫn “fun” như thường.</p>
</aside>
<div class="codehilite"><pre><span class="c">// Lưu vào biến.</span>
<span class="k">var</span> <span class="i">someVariable</span> = <span class="t">Breakfast</span>;

<span class="c">// Truyền vào hàm.</span>
<span class="i">someFunction</span>(<span class="t">Breakfast</span>);
</pre></div>
<p>Tiếp theo, chúng ta cần một cách để tạo instance. Ta có thể thêm một từ khóa <code>new</code>, nhưng để giữ mọi thứ đơn giản, trong Lox, bản thân class đóng vai trò như một factory function cho các instance. Gọi class như gọi một hàm, và nó sẽ tạo ra một instance mới của chính nó.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">breakfast</span> = <span class="t">Breakfast</span>();
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;Breakfast instance&quot;.</span>
</pre></div>
<h3><a href="#khởi-tạo-instantiation-&-initialization" id="khởi-tạo-instantiation-&-initialization"><small>3&#8202;.&#8202;9&#8202;.&#8202;5</small>Khởi tạo (Instantiation) &amp; initialization</a></h3>
<p>Các class chỉ có hành vi (behavior) thì không quá hữu ích. Ý tưởng đằng sau lập trình hướng đối tượng là đóng gói cả hành vi <em>và trạng thái</em> (state) lại với nhau. Để làm được điều đó, bạn cần có fields. Lox, giống như các ngôn ngữ dynamic typing khác, cho phép bạn tự do thêm thuộc tính (property) vào objects.</p>
<div class="codehilite"><pre><span class="i">breakfast</span>.<span class="i">meat</span> = <span class="s">&quot;sausage&quot;</span>;
<span class="i">breakfast</span>.<span class="i">bread</span> = <span class="s">&quot;sourdough&quot;</span>;
</pre></div>
<p>Gán giá trị cho một field sẽ tạo field đó nếu nó chưa tồn tại.</p>
<p>Nếu bạn muốn truy cập một field hoặc method trên object hiện tại từ bên trong một method, bạn dùng <code>this</code> quen thuộc.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">&quot;Enjoy your &quot;</span> + <span class="k">this</span>.<span class="i">meat</span> + <span class="s">&quot; and &quot;</span> +
        <span class="k">this</span>.<span class="i">bread</span> + <span class="s">&quot;, &quot;</span> + <span class="i">who</span> + <span class="s">&quot;.&quot;</span>;
  }

  <span class="c">// ...</span>
}
</pre></div>
<p>Một phần của việc đóng gói dữ liệu trong object là đảm bảo object ở trạng thái hợp lệ khi được tạo ra. Để làm điều đó, bạn có thể định nghĩa một initializer. Nếu class của bạn có một method tên <code>init()</code>, nó sẽ được gọi tự động khi object được khởi tạo. Bất kỳ tham số nào truyền vào class sẽ được chuyển tiếp đến initializer.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>) {
    <span class="k">this</span>.<span class="i">meat</span> = <span class="i">meat</span>;
    <span class="k">this</span>.<span class="i">bread</span> = <span class="i">bread</span>;
  }

  <span class="c">// ...</span>
}

<span class="k">var</span> <span class="i">baconAndToast</span> = <span class="t">Breakfast</span>(<span class="s">&quot;bacon&quot;</span>, <span class="s">&quot;toast&quot;</span>);
<span class="i">baconAndToast</span>.<span class="i">serve</span>(<span class="s">&quot;Dear Reader&quot;</span>);
<span class="c">// &quot;Enjoy your bacon and toast, Dear Reader.&quot;</span>
</pre></div>
<h3><a href="#inheritance" id="inheritance"><small>3&#8202;.&#8202;9&#8202;.&#8202;6</small>Inheritance</a></h3>
<p>Mọi ngôn ngữ hướng đối tượng đều cho phép bạn không chỉ định nghĩa methods, mà còn tái sử dụng chúng giữa nhiều class hoặc object. Để làm điều đó, Lox hỗ trợ single inheritance. Khi bạn khai báo một class, bạn có thể chỉ định class mà nó kế thừa bằng toán tử nhỏ hơn <span name="less">(<code>&lt;</code>)</span>.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brunch</span> &lt; <span class="t">Breakfast</span> {
  <span class="i">drink</span>() {
    <span class="k">print</span> <span class="s">&quot;How about a Bloody Mary?&quot;</span>;
  }
}
</pre></div>
<aside name="less">
<p>Tại sao lại dùng toán tử <code>&lt;</code>? Tôi không muốn giới thiệu thêm một từ khóa mới như <code>extends</code>. Lox cũng không dùng <code>:</code> cho thứ gì khác nên tôi cũng không muốn “giữ chỗ” cho nó. Thay vào đó, tôi học theo Ruby và dùng <code>&lt;</code>.</p>
<p>Nếu bạn biết một chút về lý thuyết kiểu (type theory), bạn sẽ nhận ra đây không phải là một lựa chọn <em>hoàn toàn</em> tùy tiện. Mọi instance của subclass cũng là instance của superclass, nhưng có thể có những instance của superclass không phải là instance của subclass. Điều đó có nghĩa là, trong “vũ trụ” các object, tập hợp các object thuộc subclass nhỏ hơn tập hợp của superclass, dù dân “mọt” kiểu thường dùng ký hiệu <code>&lt;:</code> cho quan hệ này.</p>
</aside>
<p>Ở đây, Brunch là <strong>derived class</strong> hay <strong>subclass</strong>, và Breakfast là <strong>base class</strong> hay <strong>superclass</strong>.</p>
<p>Mọi method được định nghĩa trong superclass đều có sẵn cho các subclass.</p>
<div class="codehilite"><pre><span class="k">var</span> <span class="i">benedict</span> = <span class="t">Brunch</span>(<span class="s">&quot;ham&quot;</span>, <span class="s">&quot;English muffin&quot;</span>);
<span class="i">benedict</span>.<span class="i">serve</span>(<span class="s">&quot;Noble Reader&quot;</span>);
</pre></div>
<p>Ngay cả method <code>init()</code> cũng được <span name="init">kế thừa</span>. Trên thực tế, subclass thường muốn định nghĩa method <code>init()</code> của riêng mình. Nhưng method gốc cũng cần được gọi để superclass có thể duy trì trạng thái của nó. Chúng ta cần một cách để gọi method trên <em>instance</em> của chính mình mà không “đụng” vào method của chính mình.</p>
<aside name="init">
<p>Lox khác với C++, Java và C#, vốn không kế thừa constructors, nhưng giống với Smalltalk và Ruby, vốn có kế thừa.</p>
</aside>
<p>Giống như trong Java, bạn dùng <code>super</code> cho việc đó.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="t">Brunch</span> &lt; <span class="t">Breakfast</span> {
  <span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>, <span class="i">drink</span>) {
    <span class="k">super</span>.<span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>);
    <span class="k">this</span>.<span class="i">drink</span> = <span class="i">drink</span>;
  }
}
</pre></div>
<p>Về cơ bản, đó là tất cả về lập trình hướng đối tượng trong Lox. Tôi cố gắng giữ bộ tính năng ở mức tối giản. Cấu trúc của cuốn sách buộc tôi phải chấp nhận một điểm thỏa hiệp: Lox không phải là một ngôn ngữ hướng đối tượng <em>thuần túy</em>. Trong một ngôn ngữ OOP “thật sự”, mọi object đều là instance của một class, kể cả các giá trị nguyên thủy như số và Boolean.</p>
<p>Bởi vì chúng ta không cài đặt classes cho đến khá lâu sau khi đã làm việc với các kiểu built-in, nên điều đó sẽ rất khó. Vì vậy, các giá trị kiểu nguyên thủy không phải là object “thật” theo nghĩa là instance của class. Chúng không có methods hay properties. Nếu tôi định biến Lox thành một ngôn ngữ thực sự cho người dùng thực sự, tôi sẽ sửa điều đó.</p>
<h2><a href="#the-standard-library" id="the-standard-library"><small>3&#8202;.&#8202;10</small>The Standard Library</a></h2>
<p>Chúng ta gần xong rồi. Đó là toàn bộ ngôn ngữ, nên phần còn lại chỉ là “core” hay “standard” library — tập hợp các chức năng được cài đặt trực tiếp trong interpreter và là nền tảng cho mọi hành vi do người dùng định nghĩa.</p>
<p>Đây là phần “buồn” nhất của Lox. Standard library của nó vượt xa mức tối giản và gần như chạm tới chủ nghĩa hư vô. Với các ví dụ trong sách, chúng ta chỉ cần chứng minh rằng code đang chạy và làm đúng những gì nó cần làm. Để làm điều đó, chúng ta đã có sẵn câu lệnh <code>print</code> built-in.</p>
<p>Sau này, khi bắt đầu tối ưu hóa, chúng ta sẽ viết một số benchmark và xem mất bao lâu để execute code. Điều đó có nghĩa là chúng ta cần theo dõi thời gian, nên sẽ định nghĩa một hàm built-in, <code>clock()</code>, trả về số giây kể từ khi chương trình bắt đầu chạy.</p>
<p>Và… hết rồi. Tôi biết, nghe thật xấu hổ.</p>
<p>Nếu bạn muốn biến Lox thành một ngôn ngữ thực sự hữu ích, việc đầu tiên bạn nên làm là mở rộng phần này. Xử lý chuỗi, các hàm lượng giác, file I/O, networking, thậm chí <em>đọc input từ người dùng</em> cũng sẽ giúp ích. Nhưng chúng ta không cần những thứ đó cho cuốn sách này, và thêm chúng vào cũng không dạy bạn điều gì thú vị, nên tôi đã bỏ qua.</p>
<p>Đừng lo, bản thân ngôn ngữ sẽ có đủ thứ thú vị để giữ chúng ta bận rộn.</p>
<div class="challenges">
<h2><a href="#thử-thách" id="thử-thách"><small>3&#8202;.&#8202;11</small>Thử thách</a></h2>
<ol>
<li>
<p>Viết một vài chương trình Lox mẫu và chạy chúng (bạn có thể dùng các bản cài đặt Lox trong <a href="https://github.com/munificent/craftinginterpreters">repository của tôi</a>). Hãy thử nghĩ ra các trường hợp “edge case” mà tôi chưa chỉ rõ ở đây. Nó có hoạt động như bạn mong đợi không? Tại sao có hoặc tại sao không?</p>
</li>
<li>
<p>Phần giới thiệu không chính thức này bỏ ngỏ <em>rất nhiều</em> chi tiết. Hãy liệt kê một số câu hỏi mở mà bạn có về cú pháp và ngữ nghĩa của ngôn ngữ. Bạn nghĩ câu trả lời nên như thế nào?</p>
</li>
<li>
<p>Lox là một ngôn ngữ khá nhỏ gọn. Bạn nghĩ nó thiếu những tính năng nào khiến việc dùng nó cho các chương trình thực tế trở nên bất tiện? (Tất nhiên là ngoại trừ standard library.)</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#ghi-chú-thiết-kế-expressions-&-statements" id="ghi-chú-thiết-kế-expressions-&-statements"><small>3&#8202;.&#8202;12</small>Ghi chú thiết kế: Expressions &amp; Statements</a></h2>
<p>Lox có cả expressions và statements. Một số ngôn ngữ bỏ hẳn loại thứ hai. Thay vào đó, chúng coi cả khai báo và các cấu trúc điều khiển luồng cũng là expressions. Những ngôn ngữ “mọi thứ đều là expression” này thường có nguồn gốc lập trình hàm và bao gồm hầu hết các Lisp, SML, Haskell, Ruby và CoffeeScript.</p>
<p>Để làm được điều đó, với mỗi cấu trúc “giống statement” trong ngôn ngữ, bạn cần quyết định giá trị mà nó sẽ trả về. Một số trường hợp khá dễ:</p>
<ul>
<li>
<p>Một <code>if</code> expression trả về kết quả của nhánh được chọn. Tương tự, một <code>switch</code> hoặc các cấu trúc rẽ nhánh nhiều hướng khác trả về kết quả của case được chọn.</p>
</li>
<li>
<p>Một khai báo biến trả về giá trị của biến đó.</p>
</li>
<li>
<p>Một block trả về kết quả của expression cuối cùng trong chuỗi.</p>
</li>
</ul>
<p>Một số trường hợp thì kỳ lạ hơn. Vòng lặp nên trả về gì? Trong CoffeeScript, một vòng <code>while</code> trả về một mảng chứa từng giá trị mà phần thân vòng lặp trả về. Điều này có thể hữu ích, hoặc lãng phí bộ nhớ nếu bạn không cần mảng đó.</p>
<p>Bạn cũng phải quyết định cách các expression dạng statement này kết hợp với các expression khác — tức là phải đặt chúng vào bảng độ ưu tiên (precedence table) của grammar. Ví dụ, Ruby cho phép:</p>
<div class="codehilite"><pre><span class="i">puts</span> <span class="n">1</span> + <span class="k">if</span> <span class="k">true</span> <span class="k">then</span> <span class="n">2</span> <span class="k">else</span> <span class="n">3</span> <span class="k">end</span> + <span class="n">4</span>
</pre></div>
<p>Đây có phải điều bạn mong đợi không? Có phải điều <em>người dùng</em> của bạn mong đợi không? Điều này ảnh hưởng thế nào đến cách bạn thiết kế cú pháp cho “statements” của mình? Lưu ý rằng Ruby có từ khóa <code>end</code> rõ ràng để đánh dấu khi nào <code>if</code> expression kết thúc. Nếu không có nó, <code>+ 4</code> rất có thể sẽ bị parse như một phần của mệnh đề <code>else</code>.</p>
<p>Chuyển mọi statement thành expression buộc bạn phải trả lời một vài câu hỏi “khó nhằn” như vậy. Đổi lại, bạn loại bỏ được một số sự trùng lặp. C có cả block để sắp xếp các statement, và toán tử dấu phẩy để sắp xếp các expression. Nó có cả <code>if</code> statement và toán tử điều kiện <code>?:</code>. Nếu mọi thứ trong C đều là expression, bạn có thể hợp nhất từng cặp này.</p>
<p>Các ngôn ngữ loại bỏ statements thường cũng có <strong>implicit returns</strong> — một hàm tự động trả về giá trị mà phần thân của nó đánh giá được mà không cần cú pháp <code>return</code> rõ ràng. Với các hàm và method nhỏ, điều này rất tiện. Thực tế, nhiều ngôn ngữ vốn có statements cũng đã thêm cú pháp như <code>=&gt;</code> để định nghĩa các hàm mà phần thân chỉ là kết quả của một expression duy nhất.</p>
<p>Nhưng bắt <em>tất cả</em> hàm hoạt động theo cách đó có thể hơi kỳ lạ. Nếu không cẩn thận, hàm của bạn sẽ “rò rỉ” giá trị trả về ngay cả khi bạn chỉ định nó tạo ra side effect. Tuy nhiên, trên thực tế, người dùng các ngôn ngữ này thường không thấy đó là vấn đề.</p>
<p>Với Lox, tôi giữ lại statements vì lý do thực dụng. Tôi chọn cú pháp giống C để tạo sự quen thuộc, và việc cố gắng lấy cú pháp statement của C rồi diễn giải nó như expressions sẽ trở nên kỳ quặc rất nhanh.</p>
</div>

<footer>
<a href="a-tree-walk-interpreter.html" class="next">
  Đọc tiếp Part: &ldquo;A Tree-Walk Interpreter&rdquo; &rarr;
</a>
Handcrafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
